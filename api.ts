/**
 * SendinBlue API
 * SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 
 *
 * OpenAPI spec version: 3.0.0
 * Contact: contact@sendinblue.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

const defaultBasePath = 'https://api.sendinblue.com/v3';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
const primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            const discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            const transformedData: any[] = [];
            for (const index in data) {
                const date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            const attributeTypes = typeMap[type].getAttributeTypeMap();
            const instance: {[index: string]: any} = {};
            for (const index in attributeTypes) {
                const attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            const transformedData: any[] = [];
            for (const index in data) {
                const date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            const instance = new typeMap[type]();
            const attributeTypes = typeMap[type].getAttributeTypeMap();
            for (const index in attributeTypes) {
                const attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AbTestCampaignResult {
    /**
    * Winning Campaign Info. pending = Campaign has been picked for sending and winning version is yet to be decided, tie = A tie happened between both the versions, notAvailable = Campaign has not yet been picked for sending.
    */
    'winningVersion'?: AbTestCampaignResult.WinningVersionEnum;
    /**
    * Criteria choosen for winning version (Open/Click)
    */
    'winningCriteria'?: AbTestCampaignResult.WinningCriteriaEnum;
    /**
    * Subject Line of current winning version
    */
    'winningSubjectLine'?: string;
    /**
    * Open rate for current winning version
    */
    'openRate'?: string;
    /**
    * Click rate for current winning version
    */
    'clickRate'?: string;
    /**
    * Open/Click rate for the winner version
    */
    'winningVersionRate'?: string;
    'statistics'?: AbTestCampaignResultStatistics;
    'clickedLinks'?: AbTestCampaignResultClickedLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "winningVersion",
            "baseName": "winningVersion",
            "type": "AbTestCampaignResult.WinningVersionEnum"
        },
        {
            "name": "winningCriteria",
            "baseName": "winningCriteria",
            "type": "AbTestCampaignResult.WinningCriteriaEnum"
        },
        {
            "name": "winningSubjectLine",
            "baseName": "winningSubjectLine",
            "type": "string"
        },
        {
            "name": "openRate",
            "baseName": "openRate",
            "type": "string"
        },
        {
            "name": "clickRate",
            "baseName": "clickRate",
            "type": "string"
        },
        {
            "name": "winningVersionRate",
            "baseName": "winningVersionRate",
            "type": "string"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "AbTestCampaignResultStatistics"
        },
        {
            "name": "clickedLinks",
            "baseName": "clickedLinks",
            "type": "AbTestCampaignResultClickedLinks"
        }    ];

    static getAttributeTypeMap() {
        return AbTestCampaignResult.attributeTypeMap;
    }
}

export namespace AbTestCampaignResult {
    export enum WinningVersionEnum {
        NotAvailable = <any> 'notAvailable',
        Pending = <any> 'pending',
        Tie = <any> 'tie',
        A = <any> 'A',
        B = <any> 'B'
    }
    export enum WinningCriteriaEnum {
        Open = <any> 'Open',
        Click = <any> 'Click'
    }
}
export class AbTestCampaignResultClickedLinks {
    'versionA': AbTestVersionClicks;
    'versionB': AbTestVersionClicks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "versionA",
            "baseName": "Version A",
            "type": "AbTestVersionClicks"
        },
        {
            "name": "versionB",
            "baseName": "Version B",
            "type": "AbTestVersionClicks"
        }    ];

    static getAttributeTypeMap() {
        return AbTestCampaignResultClickedLinks.attributeTypeMap;
    }
}

export class AbTestCampaignResultStatistics {
    'openers': AbTestVersionStats;
    'clicks': AbTestVersionStats;
    'unsubscribed': AbTestVersionStats;
    'hardBounces': AbTestVersionStats;
    'softBounces': AbTestVersionStats;
    'complaints': AbTestVersionStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "openers",
            "baseName": "openers",
            "type": "AbTestVersionStats"
        },
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "AbTestVersionStats"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "AbTestVersionStats"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "AbTestVersionStats"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "AbTestVersionStats"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "AbTestVersionStats"
        }    ];

    static getAttributeTypeMap() {
        return AbTestCampaignResultStatistics.attributeTypeMap;
    }
}

/**
* Information on clicked links for a particular version
*/
export class AbTestVersionClicks extends Array<AbTestVersionClicksInner> {

    static discriminator: string | undefined = undefined;

}

export class AbTestVersionClicksInner {
    /**
    * URL of the link
    */
    'link': string;
    /**
    * Number of times a link is clicked
    */
    'clicksCount': number;
    /**
    * Percentage of clicks of link with respect to total clicks
    */
    'clickRate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "clicksCount",
            "baseName": "clicksCount",
            "type": "number"
        },
        {
            "name": "clickRate",
            "baseName": "clickRate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AbTestVersionClicksInner.attributeTypeMap;
    }
}

/**
* Percentage of a particular event for both versions
*/
export class AbTestVersionStats {
    /**
    * percentage of an event for version A
    */
    'versionA': string;
    /**
    * percentage of an event for version B
    */
    'versionB': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "versionA",
            "baseName": "Version A",
            "type": "string"
        },
        {
            "name": "versionB",
            "baseName": "Version B",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AbTestVersionStats.attributeTypeMap;
    }
}

export class AddChildDomain {
    /**
    * Sender domain to add for a specific child account
    */
    'domain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddChildDomain.attributeTypeMap;
    }
}

export class AddContactToList {
    /**
    * Mandatory if IDs are not passed, ignored otherwise. Emails to add to a list. You can pass a maximum of 150 emails for addition in one request. If you need to add the emails in bulk, please prefer /contacts/import api.
    */
    'emails'?: Array<string>;
    /**
    * Mandatory if Emails are not passed, ignored otherwise. Emails to add to a list. You can pass a maximum of 150 emails for addition in one request. If you need to add the emails in bulk, please prefer /contacts/import api.
    */
    'ids'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        },
        {
            "name": "ids",
            "baseName": "ids",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return AddContactToList.attributeTypeMap;
    }
}

export class AddCredits {
    /**
    * Required if email credits are empty. SMS credits to be added to the child account
    */
    'sms'?: number;
    /**
    * Required if sms credits are empty. Email credits to be added to the child account
    */
    'email'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AddCredits.attributeTypeMap;
    }
}

export class BlockDomain {
    /**
    * name of the domain to be blocked
    */
    'domain': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BlockDomain.attributeTypeMap;
    }
}

export class CreateAttribute {
    /**
    * Value of the attribute. Use only if the attribute's category is 'calculated' or 'global'
    */
    'value'?: string;
    /**
    * List of values and labels that the attribute can take. Use only if the attribute's category is \"category\". For example, [{\"value\":1, \"label\":\"male\"}, {\"value\":2, \"label\":\"female\"}]
    */
    'enumeration'?: Array<CreateAttributeEnumeration>;
    /**
    * Type of the attribute. Use only if the attribute's category is 'normal', 'category' or 'transactional' ( type 'boolean' is only available if the category is 'normal' attribute, type 'id' is only available if the category is 'transactional' attribute & type 'category' is only available if the category is 'category' attribute )
    */
    'type'?: CreateAttribute.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "enumeration",
            "baseName": "enumeration",
            "type": "Array<CreateAttributeEnumeration>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CreateAttribute.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateAttribute.attributeTypeMap;
    }
}

export namespace CreateAttribute {
    export enum TypeEnum {
        Text = <any> 'text',
        Date = <any> 'date',
        Float = <any> 'float',
        Boolean = <any> 'boolean',
        Id = <any> 'id',
        Category = <any> 'category'
    }
}
export class CreateAttributeEnumeration {
    /**
    * Id of the value
    */
    'value': number;
    /**
    * Label of the value
    */
    'label': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAttributeEnumeration.attributeTypeMap;
    }
}

export class CreateChild {
    /**
    * Email address to create the child account
    */
    'email': string;
    /**
    * First name to use to create the child account
    */
    'firstName': string;
    /**
    * Last name to use to create the child account
    */
    'lastName': string;
    /**
    * Company name to use to create the child account
    */
    'companyName': string;
    /**
    * Password for the child account to login
    */
    'password': string;
    /**
    * Language of the child account
    */
    'language'?: CreateChild.LanguageEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "CreateChild.LanguageEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateChild.attributeTypeMap;
    }
}

export namespace CreateChild {
    export enum LanguageEnum {
        Fr = <any> 'fr',
        Es = <any> 'es',
        Pt = <any> 'pt',
        It = <any> 'it',
        De = <any> 'de',
        En = <any> 'en'
    }
}
export class CreateContact {
    /**
    * Email address of the user. Mandatory if \"SMS\" field is not passed in \"attributes\" parameter. Mobile Number in \"SMS\" field should be passed with proper country code. For example {\"SMS\":\"+91xxxxxxxxxx\"} or {\"SMS\":\"0091xxxxxxxxxx\"}
    */
    'email'?: string;
    /**
    * Pass the set of attributes and their values. These attributes must be present in your SendinBlue account. For eg. {\"FNAME\":\"Elly\", \"LNAME\":\"Roger\"}
    */
    'attributes'?: any;
    /**
    * Set this field to blacklist the contact for emails (emailBlacklisted = true)
    */
    'emailBlacklisted'?: boolean;
    /**
    * Set this field to blacklist the contact for SMS (smsBlacklisted = true)
    */
    'smsBlacklisted'?: boolean;
    /**
    * Ids of the lists to add the contact to
    */
    'listIds'?: Array<number>;
    /**
    * Facilitate to update the existing contact in the same request (updateEnabled = true)
    */
    'updateEnabled'?: boolean;
    /**
    * transactional email forbidden sender for contact. Use only for email Contact ( only available if updateEnabled = true )
    */
    'smtpBlacklistSender'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "updateEnabled",
            "baseName": "updateEnabled",
            "type": "boolean"
        },
        {
            "name": "smtpBlacklistSender",
            "baseName": "smtpBlacklistSender",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateContact.attributeTypeMap;
    }
}

export class CreateDoiContact {
    /**
    * Email address where the confirmation email will be sent. This email address will be the identifier for all other contact attributes.
    */
    'email': string;
    /**
    * Pass the set of attributes and their values. These attributes must be present in your SendinBlue account. For eg. {'FNAME':'Elly', 'LNAME':'Roger'}
    */
    'attributes'?: any;
    /**
    * Lists under user account where contact should be added
    */
    'includeListIds': Array<number>;
    /**
    * Lists under user account where contact should not be added
    */
    'excludeListIds'?: Array<number>;
    /**
    * Id of the Double opt-in (DOI) template
    */
    'templateId': number;
    /**
    * URL of the web page that user will be redirected to after clicking on the double opt in URL. When editing your DOI template you can reference this URL by using the tag {{ params.DOIurl }}.
    */
    'redirectionUrl': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "includeListIds",
            "baseName": "includeListIds",
            "type": "Array<number>"
        },
        {
            "name": "excludeListIds",
            "baseName": "excludeListIds",
            "type": "Array<number>"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "redirectionUrl",
            "baseName": "redirectionUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateDoiContact.attributeTypeMap;
    }
}

export class CreateEmailCampaign {
    /**
    * Tag of the campaign
    */
    'tag'?: string;
    'sender': CreateEmailCampaignSender;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Mandatory if htmlUrl and templateId are empty. Body of the message (HTML)
    */
    'htmlContent'?: string;
    /**
    * Mandatory if htmlContent and templateId are empty. Url to the message (HTML)
    */
    'htmlUrl'?: string;
    /**
    * Mandatory if htmlContent and htmlUrl are empty. Id of the transactional email template with status 'active'. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.
    */
    'templateId'?: number;
    /**
    * Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
    */
    'scheduledAt'?: string;
    /**
    * Subject of the campaign. Mandatory if abTesting is false. Ignored if abTesting is true.
    */
    'subject'?: string;
    /**
    * Email on which the campaign recipients will be able to reply to
    */
    'replyTo'?: string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField'?: string;
    'recipients'?: CreateEmailCampaignRecipients;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl'?: string;
    /**
    * Use true to embedded the images in your email. Final size of the email should be less than 4MB. Campaigns with embedded images can not be sent to more than 5000 contacts
    */
    'inlineImageActivation'?: boolean;
    /**
    * Use true to enable the mirror link
    */
    'mirrorActive'?: boolean;
    /**
    * Footer of the email campaign
    */
    'footer'?: string;
    /**
    * Header of the email campaign
    */
    'header'?: string;
    /**
    * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
    */
    'utmCampaign'?: string;
    /**
    * Pass the set of attributes to customize the type classic campaign. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. Only available if 'type' is 'classic'. It's considered only if campaign is in New Template Language format. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
    */
    'params'?: any;
    /**
    * Set this to true if you want to send your campaign at best time.
    */
    'sendAtBestTime'?: boolean;
    /**
    * Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered when abTesting is set to true. 'subjectA' & 'subjectB' are mandatory together & 'subject' if passed is ignored. Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
    */
    'abTesting'?: boolean;
    /**
    * Subject A of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectA'?: string;
    /**
    * Subject B of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectB'?: string;
    /**
    * Add the size of your test groups. Mandatory if abTesting = true & 'recipients' is passed. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
    */
    'splitRule'?: number;
    /**
    * Choose the metrics that will determinate the winning version. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed
    */
    'winnerCriteria'?: CreateEmailCampaign.WinnerCriteriaEnum;
    /**
    * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed
    */
    'winnerDelay'?: number;
    /**
    * Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
    */
    'ipWarmupEnable'?: boolean;
    /**
    * Mandatory if ipWarmupEnable is set to true. Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
    */
    'initialQuota'?: number;
    /**
    * Mandatory if ipWarmupEnable is set to true. Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
    */
    'increaseRate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "CreateEmailCampaignSender"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "CreateEmailCampaignRecipients"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "CreateEmailCampaign.WinnerCriteriaEnum"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        },
        {
            "name": "ipWarmupEnable",
            "baseName": "ipWarmupEnable",
            "type": "boolean"
        },
        {
            "name": "initialQuota",
            "baseName": "initialQuota",
            "type": "number"
        },
        {
            "name": "increaseRate",
            "baseName": "increaseRate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailCampaign.attributeTypeMap;
    }
}

export namespace CreateEmailCampaign {
    export enum WinnerCriteriaEnum {
        Open = <any> 'open',
        Click = <any> 'click'
    }
}
/**
* List ids to include/exclude from campaign
*/
export class CreateEmailCampaignRecipients {
    /**
    * List ids to exclude from the campaign
    */
    'exclusionListIds'?: Array<number>;
    /**
    * Mandatory if scheduledAt is not empty. List Ids to send the campaign to
    */
    'listIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exclusionListIds",
            "baseName": "exclusionListIds",
            "type": "Array<number>"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailCampaignRecipients.attributeTypeMap;
    }
}

/**
* Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
*/
export class CreateEmailCampaignSender {
    /**
    * Sender Name
    */
    'name'?: string;
    /**
    * Sender email
    */
    'email': string;
    /**
    * Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailCampaignSender.attributeTypeMap;
    }
}

export class CreateList {
    /**
    * Name of the list
    */
    'name': string;
    /**
    * Id of the parent folder in which this list is to be created
    */
    'folderId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateList.attributeTypeMap;
    }
}

export class CreateModel {
    /**
    * ID of the object created
    */
    'id': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateModel.attributeTypeMap;
    }
}

export class CreateReseller {
    /**
    * AuthKey of Reseller child created
    */
    'authKey': string;
    /**
    * Id of Reseller child created
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authKey",
            "baseName": "authKey",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateReseller.attributeTypeMap;
    }
}

export class CreateSender {
    /**
    * From Name to use for the sender
    */
    'name': string;
    /**
    * From email to use for the sender. A verification email will be sent to this address.
    */
    'email': string;
    /**
    * Mandatory in case of dedicated IP, IPs to associate to the sender
    */
    'ips'?: Array<CreateSenderIps>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<CreateSenderIps>"
        }    ];

    static getAttributeTypeMap() {
        return CreateSender.attributeTypeMap;
    }
}

export class CreateSenderIps {
    /**
    * Dedicated IP available in your account
    */
    'ip': string;
    /**
    * Domain of the IP
    */
    'domain': string;
    /**
    * Weight to apply to the IP. Sum of all IP weights must be 100. Should be passed for either ALL or NONE of the IPs. If it's not passed, the sending will be equally balanced on all IPs.
    */
    'weight'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateSenderIps.attributeTypeMap;
    }
}

export class CreateSenderModel {
    /**
    * ID of the Sender created
    */
    'id': number;
    /**
    * Status of SPF configuration for the sender (true = SPF not well configured, false = SPF well configured)
    */
    'spfError'?: boolean;
    /**
    * Status of DKIM configuration for the sender (true = DKIM not well configured, false = DKIM well configured)
    */
    'dkimError'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "spfError",
            "baseName": "spfError",
            "type": "boolean"
        },
        {
            "name": "dkimError",
            "baseName": "dkimError",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateSenderModel.attributeTypeMap;
    }
}

export class CreateSmsCampaign {
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**
    */
    'sender': string;
    /**
    * Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
    */
    'content': string;
    'recipients'?: CreateSmsCampaignRecipients;
    /**
    * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
    */
    'scheduledAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "CreateSmsCampaignRecipients"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmsCampaign.attributeTypeMap;
    }
}

export class CreateSmsCampaignRecipients {
    /**
    * Lists Ids to send the campaign to. REQUIRED if scheduledAt is not empty
    */
    'listIds': Array<number>;
    /**
    * List ids which have to be excluded from a campaign
    */
    'exclusionListIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "exclusionListIds",
            "baseName": "exclusionListIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmsCampaignRecipients.attributeTypeMap;
    }
}

export class CreateSmtpEmail {
    /**
    * Message ID of the transactional email sent
    */
    'messageId'?: string;
    'messageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "messageIds",
            "baseName": "messageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmtpEmail.attributeTypeMap;
    }
}

export class CreateSmtpTemplate {
    /**
    * Tag of the template
    */
    'tag'?: string;
    'sender': CreateSmtpTemplateSender;
    /**
    * Name of the template
    */
    'templateName': string;
    /**
    * Body of the message (HTML version). The field must have more than 10 characters. REQUIRED if htmlUrl is empty
    */
    'htmlContent'?: string;
    /**
    * Url which contents the body of the email message. REQUIRED if htmlContent is empty
    */
    'htmlUrl'?: string;
    /**
    * Subject of the template
    */
    'subject': string;
    /**
    * Email on which campaign recipients will be able to reply to
    */
    'replyTo'?: string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField'?: string;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl'?: string;
    /**
    * Status of template. isActive = true means template is active and isActive = false means template is inactive
    */
    'isActive'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "CreateSmtpTemplateSender"
        },
        {
            "name": "templateName",
            "baseName": "templateName",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmtpTemplate.attributeTypeMap;
    }
}

/**
* Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
*/
export class CreateSmtpTemplateSender {
    /**
    * Name of the sender. If not passed, will be set to default
    */
    'name'?: string;
    /**
    * Email of the sender
    */
    'email'?: string;
    /**
    * Select the sender for the template on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateSmtpTemplateSender.attributeTypeMap;
    }
}

export class CreateUpdateContactModel {
    /**
    * ID of the contact when a new contact is created
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreateUpdateContactModel.attributeTypeMap;
    }
}

export class CreateUpdateFolder {
    /**
    * Name of the folder
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateUpdateFolder.attributeTypeMap;
    }
}

export class CreateWebhook {
    /**
    * URL of the webhook
    */
    'url': string;
    /**
    * Description of the webhook
    */
    'description'?: string;
    /**
    * Events triggering the webhook. Possible values for Transactional type webhook – `sent` OR `request`, `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`, `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and `unsubscribed` and possible values for Marketing type webhook – `spam`, `opened`, `click`, `hardBounce`, `softBounce`, `unsubscribed`, `listAddition` & `delivered`
    */
    'events': Array<CreateWebhook.EventsEnum>;
    /**
    * Type of the webhook
    */
    'type'?: CreateWebhook.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<CreateWebhook.EventsEnum>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CreateWebhook.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateWebhook.attributeTypeMap;
    }
}

export namespace CreateWebhook {
    export enum EventsEnum {
        Sent = <any> 'sent',
        HardBounce = <any> 'hardBounce',
        SoftBounce = <any> 'softBounce',
        Blocked = <any> 'blocked',
        Spam = <any> 'spam',
        Delivered = <any> 'delivered',
        Request = <any> 'request',
        Click = <any> 'click',
        Invalid = <any> 'invalid',
        Deferred = <any> 'deferred',
        Opened = <any> 'opened',
        UniqueOpened = <any> 'uniqueOpened',
        Unsubscribed = <any> 'unsubscribed',
        ListAddition = <any> 'listAddition',
        ContactUpdated = <any> 'contactUpdated',
        ContactDeleted = <any> 'contactDeleted'
    }
    export enum TypeEnum {
        Transactional = <any> 'transactional',
        Marketing = <any> 'marketing'
    }
}
export class CreatedProcessId {
    /**
    * Id of the process created
    */
    'processId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processId",
            "baseName": "processId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CreatedProcessId.attributeTypeMap;
    }
}

export class DeleteHardbounces {
    /**
    * Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate
    */
    'startDate'?: string;
    /**
    * Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate
    */
    'endDate'?: string;
    /**
    * Target a specific email address
    */
    'contactEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "string"
        },
        {
            "name": "contactEmail",
            "baseName": "contactEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteHardbounces.attributeTypeMap;
    }
}

export class EmailExportRecipients {
    /**
    * Webhook called once the export process is finished. For reference, https://help.sendinblue.com/hc/en-us/articles/360007666479
    */
    'notifyURL'?: string;
    /**
    * Type of recipients to export for a campaign
    */
    'recipientsType': EmailExportRecipients.RecipientsTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifyURL",
            "baseName": "notifyURL",
            "type": "string"
        },
        {
            "name": "recipientsType",
            "baseName": "recipientsType",
            "type": "EmailExportRecipients.RecipientsTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return EmailExportRecipients.attributeTypeMap;
    }
}

export namespace EmailExportRecipients {
    export enum RecipientsTypeEnum {
        All = <any> 'all',
        NonClickers = <any> 'nonClickers',
        NonOpeners = <any> 'nonOpeners',
        Clickers = <any> 'clickers',
        Openers = <any> 'openers',
        SoftBounces = <any> 'softBounces',
        HardBounces = <any> 'hardBounces',
        Unsubscribed = <any> 'unsubscribed'
    }
}
export class ErrorModel {
    /**
    * Error code displayed in case of a failure
    */
    'code': ErrorModel.CodeEnum;
    /**
    * Readable message associated to the failure
    */
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "ErrorModel.CodeEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorModel.attributeTypeMap;
    }
}

export namespace ErrorModel {
    export enum CodeEnum {
        InvalidParameter = <any> 'invalid_parameter',
        MissingParameter = <any> 'missing_parameter',
        OutOfRange = <any> 'out_of_range',
        CampaignProcessing = <any> 'campaign_processing',
        CampaignSent = <any> 'campaign_sent',
        DocumentNotFound = <any> 'document_not_found',
        ResellerPermissionDenied = <any> 'reseller_permission_denied',
        NotEnoughCredits = <any> 'not_enough_credits',
        PermissionDenied = <any> 'permission_denied',
        DuplicateParameter = <any> 'duplicate_parameter',
        DuplicateRequest = <any> 'duplicate_request',
        MethodNotAllowed = <any> 'method_not_allowed',
        Unauthorized = <any> 'unauthorized',
        AccountUnderValidation = <any> 'account_under_validation',
        NotAcceptable = <any> 'not_acceptable'
    }
}

export class GetAccountMarketingAutomation {
    /**
    * Marketing Automation Tracker ID
    */
    'key'?: string;
    /**
    * Status of Marketing Automation Plateform activation for your account (true=enabled, false=disabled)
    */
    'enabled': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountMarketingAutomation.attributeTypeMap;
    }
}

export class GetAccountPlan {
    /**
    * Displays the plan type of the user
    */
    'type': GetAccountPlan.TypeEnum;
    /**
    * This is the type of the credit, \"Send Limit\" is one of the possible types of credit of a user. \"Send Limit\" implies the total number of emails you can send to the subscribers in your account.
    */
    'creditsType': GetAccountPlan.CreditsTypeEnum;
    /**
    * Remaining credits of the user
    */
    'credits': number;
    /**
    * Date of the period from which the plan will start (only available for \"subscription\" and \"reseller\" plan type)
    */
    'startDate'?: string;
    /**
    * Date of the period from which the plan will end (only available for \"subscription\" and \"reseller\" plan type)
    */
    'endDate'?: string;
    /**
    * Only in case of reseller account. It implies the total number of child accounts you can add to your account.
    */
    'userLimit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "GetAccountPlan.TypeEnum"
        },
        {
            "name": "creditsType",
            "baseName": "creditsType",
            "type": "GetAccountPlan.CreditsTypeEnum"
        },
        {
            "name": "credits",
            "baseName": "credits",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "string"
        },
        {
            "name": "userLimit",
            "baseName": "userLimit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountPlan.attributeTypeMap;
    }
}

export namespace GetAccountPlan {
    export enum TypeEnum {
        PayAsYouGo = <any> 'payAsYouGo',
        Free = <any> 'free',
        Subscription = <any> 'subscription',
        Sms = <any> 'sms',
        Reseller = <any> 'reseller'
    }
    export enum CreditsTypeEnum {
        SendLimit = <any> 'sendLimit'
    }
}
/**
* Information about your transactional email account
*/
export class GetAccountRelay {
    /**
    * Status of your transactional email Account (true=Enabled, false=Disabled)
    */
    'enabled': boolean;
    'data': GetAccountRelayData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "GetAccountRelayData"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountRelay.attributeTypeMap;
    }
}

/**
* Data regarding the transactional email account
*/
export class GetAccountRelayData {
    /**
    * Email to use as login on transactional platform
    */
    'userName': string;
    /**
    * URL of the SMTP Relay
    */
    'relay': string;
    /**
    * Port used for SMTP Relay
    */
    'port': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "relay",
            "baseName": "relay",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAccountRelayData.attributeTypeMap;
    }
}

export class GetAggregatedReport {
    /**
    * Time frame of the report
    */
    'range'?: string;
    /**
    * Number of requests for the timeframe
    */
    'requests'?: number;
    /**
    * Number of delivered emails for the timeframe
    */
    'delivered'?: number;
    /**
    * Number of hardbounces for the timeframe
    */
    'hardBounces'?: number;
    /**
    * Number of softbounces for the timeframe
    */
    'softBounces'?: number;
    /**
    * Number of clicks for the timeframe
    */
    'clicks'?: number;
    /**
    * Number of unique clicks for the timeframe
    */
    'uniqueClicks'?: number;
    /**
    * Number of openings for the timeframe
    */
    'opens'?: number;
    /**
    * Number of unique openings for the timeframe
    */
    'uniqueOpens'?: number;
    /**
    * Number of complaint (spam report) for the timeframe
    */
    'spamReports'?: number;
    /**
    * Number of blocked contact emails for the timeframe
    */
    'blocked'?: number;
    /**
    * Number of invalid emails for the timeframe
    */
    'invalid'?: number;
    /**
    * Number of unsubscribed emails for the timeframe
    */
    'unsubscribed'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "range",
            "baseName": "range",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "opens",
            "baseName": "opens",
            "type": "number"
        },
        {
            "name": "uniqueOpens",
            "baseName": "uniqueOpens",
            "type": "number"
        },
        {
            "name": "spamReports",
            "baseName": "spamReports",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "invalid",
            "baseName": "invalid",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetAggregatedReport.attributeTypeMap;
    }
}

export class GetAttributes {
    /**
    * Listing of available contact attributes in your account
    */
    'attributes': Array<GetAttributesAttributes>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<GetAttributesAttributes>"
        }    ];

    static getAttributeTypeMap() {
        return GetAttributes.attributeTypeMap;
    }
}

export class GetAttributesAttributes {
    /**
    * Name of the attribute
    */
    'name': string;
    /**
    * Category of the attribute
    */
    'category': GetAttributesAttributes.CategoryEnum;
    /**
    * Type of the attribute
    */
    'type'?: GetAttributesAttributes.TypeEnum;
    /**
    * Parameter only available for \"category\" type attributes.
    */
    'enumeration'?: Array<GetAttributesEnumeration>;
    /**
    * Calculated value formula
    */
    'calculatedValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "GetAttributesAttributes.CategoryEnum"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetAttributesAttributes.TypeEnum"
        },
        {
            "name": "enumeration",
            "baseName": "enumeration",
            "type": "Array<GetAttributesEnumeration>"
        },
        {
            "name": "calculatedValue",
            "baseName": "calculatedValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAttributesAttributes.attributeTypeMap;
    }
}

export namespace GetAttributesAttributes {
    export enum CategoryEnum {
        Normal = <any> 'normal',
        Transactional = <any> 'transactional',
        Category = <any> 'category',
        Calculated = <any> 'calculated',
        Global = <any> 'global'
    }
    export enum TypeEnum {
        Text = <any> 'text',
        Date = <any> 'date',
        Float = <any> 'float',
        Id = <any> 'id',
        Boolean = <any> 'boolean'
    }
}
export class GetAttributesEnumeration {
    /**
    * ID of Value of the \"category\" type attribute
    */
    'value': number;
    /**
    * Label of the \"category\" type attribute
    */
    'label': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAttributesEnumeration.attributeTypeMap;
    }
}

/**
* list of blocked domains
*/
export class GetBlockedDomains {
    /**
    * List of all blocked domains
    */
    'domains': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domains",
            "baseName": "domains",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GetBlockedDomains.attributeTypeMap;
    }
}

export class GetCampaignOverview {
    /**
    * ID of the campaign
    */
    'id': number;
    /**
    * Name of the campaign
    */
    'name': string;
    /**
    * Subject of the campaign. Only available if `abTesting` flag of the campaign is `false`
    */
    'subject'?: string;
    /**
    * Type of campaign
    */
    'type': GetCampaignOverview.TypeEnum;
    /**
    * Status of the campaign
    */
    'status': GetCampaignOverview.StatusEnum;
    /**
    * UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'scheduledAt'?: string;
    /**
    * Status of A/B Test for the campaign. abTesting = false means it is disabled, & abTesting = true means it is enabled.
    */
    'abTesting'?: boolean;
    /**
    * Subject A of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectA'?: string;
    /**
    * Subject B of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
    */
    'subjectB'?: string;
    /**
    * The size of your ab-test groups. Only available if `abTesting` flag of the campaign is `true`
    */
    'splitRule'?: number;
    /**
    * Criteria for the winning version. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerCriteria'?: string;
    /**
    * The duration of the test in hours at the end of which the winning version will be sent. Only available if `abTesting` flag of the campaign is `true`
    */
    'winnerDelay'?: number;
    /**
    * It is true if you have chosen to send your campaign at best time, otherwise it is false
    */
    'sendAtBestTime'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetCampaignOverview.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetCampaignOverview.StatusEnum"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "string"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "string"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetCampaignOverview.attributeTypeMap;
    }
}

export namespace GetCampaignOverview {
    export enum TypeEnum {
        Classic = <any> 'classic',
        Trigger = <any> 'trigger'
    }
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'in_process'
    }
}
export class GetCampaignRecipients {
    'lists': Array<number>;
    'exclusionLists': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<number>"
        },
        {
            "name": "exclusionLists",
            "baseName": "exclusionLists",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return GetCampaignRecipients.attributeTypeMap;
    }
}

export class GetCampaignStats {
    /**
    * List Id of email campaign (only in case of get email campaign(s)(not for global stats))
    */
    'listId'?: number;
    /**
    * Number of unique clicks for the campaign
    */
    'uniqueClicks': number;
    /**
    * Number of total clicks for the campaign
    */
    'clickers': number;
    /**
    * Number of complaints (Spam reports) for the campaign
    */
    'complaints': number;
    /**
    * Number of delivered emails for the campaign
    */
    'delivered': number;
    /**
    * Number of sent emails for the campaign
    */
    'sent': number;
    /**
    * Number of softbounce for the campaign
    */
    'softBounces': number;
    /**
    * Number of harbounce for the campaign
    */
    'hardBounces': number;
    /**
    * Number of unique openings for the campaign
    */
    'uniqueViews': number;
    /**
    * Number of unsubscription for the campaign
    */
    'unsubscriptions': number;
    /**
    * Number of openings for the campaign
    */
    'viewed': number;
    /**
    * Number of deferred emails for the campaign
    */
    'deferred'?: number;
    /**
    * Total number of non-delivered campaigns for a particular campaign id.
    */
    'returnBounce'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listId",
            "baseName": "listId",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "clickers",
            "baseName": "clickers",
            "type": "number"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "sent",
            "baseName": "sent",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "uniqueViews",
            "baseName": "uniqueViews",
            "type": "number"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "number"
        },
        {
            "name": "viewed",
            "baseName": "viewed",
            "type": "number"
        },
        {
            "name": "deferred",
            "baseName": "deferred",
            "type": "number"
        },
        {
            "name": "returnBounce",
            "baseName": "returnBounce",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetCampaignStats.attributeTypeMap;
    }
}

export class GetChildAccountCreationStatus {
    /**
    * Status of child account creation whether it is successfully created (exists) or not.
    */
    'childAccountCreated': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "childAccountCreated",
            "baseName": "childAccountCreated",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetChildAccountCreationStatus.attributeTypeMap;
    }
}

export class GetChildDomain {
    /**
    * Sender domain
    */
    'domain'?: string;
    /**
    * indicates whether a domain is verified or not
    */
    'active'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetChildDomain.attributeTypeMap;
    }
}

export class GetChildDomains extends Array<any> {

    static discriminator: string | undefined = undefined;

}

/**
* API Keys associated to child account
*/
export class GetChildInfoApiKeys {
    'v2': Array<GetChildInfoApiKeysV2>;
    'v3'?: Array<GetChildInfoApiKeysV3>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "v2",
            "baseName": "v2",
            "type": "Array<GetChildInfoApiKeysV2>"
        },
        {
            "name": "v3",
            "baseName": "v3",
            "type": "Array<GetChildInfoApiKeysV3>"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoApiKeys.attributeTypeMap;
    }
}

export class GetChildInfoApiKeysV2 {
    /**
    * Name of the key for version 2
    */
    'name': string;
    /**
    * API Key for version 2
    */
    'key': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoApiKeysV2.attributeTypeMap;
    }
}

export class GetChildInfoApiKeysV3 {
    /**
    * Name of the key for version 3
    */
    'name': string;
    /**
    * API Key for version 3
    */
    'key': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoApiKeysV3.attributeTypeMap;
    }
}

/**
* Credits available for your child
*/
export class GetChildInfoCredits {
    /**
    * Email credits available for your child
    */
    'emailCredits'?: number;
    /**
    * SMS credits available for your child
    */
    'smsCredits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailCredits",
            "baseName": "emailCredits",
            "type": "number"
        },
        {
            "name": "smsCredits",
            "baseName": "smsCredits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoCredits.attributeTypeMap;
    }
}

/**
* Statistics about your child account activity
*/
export class GetChildInfoStatistics {
    /**
    * Overall emails sent for the previous month
    */
    'previousMonthTotalSent'?: number;
    /**
    * Overall emails sent for current month
    */
    'currentMonthTotalSent'?: number;
    /**
    * Overall emails sent for since the account exists
    */
    'totalSent'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "previousMonthTotalSent",
            "baseName": "previousMonthTotalSent",
            "type": "number"
        },
        {
            "name": "currentMonthTotalSent",
            "baseName": "currentMonthTotalSent",
            "type": "number"
        },
        {
            "name": "totalSent",
            "baseName": "totalSent",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetChildInfoStatistics.attributeTypeMap;
    }
}

export class GetChildrenList {
    /**
    * Your children's account information
    */
    'children'?: Array<any>;
    /**
    * Number of child accounts
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetChildrenList.attributeTypeMap;
    }
}

export class GetClient {
    /**
    * Login Email
    */
    'email': string;
    /**
    * First Name
    */
    'firstName': string;
    /**
    * Last Name
    */
    'lastName': string;
    /**
    * Name of the company
    */
    'companyName': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetClient.attributeTypeMap;
    }
}

export class GetChildInfo extends GetClient {
    'credits'?: GetChildInfoCredits;
    'statistics'?: GetChildInfoStatistics;
    /**
    * The encrypted password of child account
    */
    'password': string;
    /**
    * IP(s) associated to a child account user
    */
    'ips'?: Array<string>;
    'apiKeys'?: GetChildInfoApiKeys;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credits",
            "baseName": "credits",
            "type": "GetChildInfoCredits"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "GetChildInfoStatistics"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<string>"
        },
        {
            "name": "apiKeys",
            "baseName": "apiKeys",
            "type": "GetChildInfoApiKeys"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetChildInfo.attributeTypeMap);
    }
}

/**
* Campaign Statistics for the contact
*/
export class GetContactCampaignStats {
    'messagesSent'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'hardBounces'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'softBounces'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'complaints'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'unsubscriptions'?: GetContactCampaignStatsUnsubscriptions;
    'opened'?: Array<GetContactCampaignStatsOpened>;
    'clicked'?: Array<GetContactCampaignStatsClicked>;
    'transacAttributes'?: Array<GetContactCampaignStatsTransacAttributes>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messagesSent",
            "baseName": "messagesSent",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "GetContactCampaignStatsUnsubscriptions"
        },
        {
            "name": "opened",
            "baseName": "opened",
            "type": "Array<GetContactCampaignStatsOpened>"
        },
        {
            "name": "clicked",
            "baseName": "clicked",
            "type": "Array<GetContactCampaignStatsClicked>"
        },
        {
            "name": "transacAttributes",
            "baseName": "transacAttributes",
            "type": "Array<GetContactCampaignStatsTransacAttributes>"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStats.attributeTypeMap;
    }
}

export class GetContactCampaignStatsClicked {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    'links': Array<GetExtendedContactDetailsStatisticsLinks>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<GetExtendedContactDetailsStatisticsLinks>"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsClicked.attributeTypeMap;
    }
}

export class GetContactCampaignStatsOpened {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * Number of openings of the campaign
    */
    'count': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': string;
    /**
    * IP from which the user has opened the campaign
    */
    'ip': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsOpened.attributeTypeMap;
    }
}

export class GetContactCampaignStatsTransacAttributes {
    /**
    * Date of the order
    */
    'orderDate': string;
    /**
    * Price of the order
    */
    'orderPrice': number;
    /**
    * ID of the order
    */
    'orderId': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderDate",
            "baseName": "orderDate",
            "type": "string"
        },
        {
            "name": "orderPrice",
            "baseName": "orderPrice",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "orderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsTransacAttributes.attributeTypeMap;
    }
}

export class GetContactCampaignStatsUnsubscriptions {
    /**
    * Contact has unsubscribed via the unsubscription link in the email
    */
    'userUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>;
    /**
    * Contact has been unsubscribed from the administrator
    */
    'adminUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userUnsubscription",
            "baseName": "userUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>"
        },
        {
            "name": "adminUnsubscription",
            "baseName": "adminUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>"
        }    ];

    static getAttributeTypeMap() {
        return GetContactCampaignStatsUnsubscriptions.attributeTypeMap;
    }
}

export class GetContactDetails {
    /**
    * Email address of the contact for which you requested the details
    */
    'email': string;
    /**
    * ID of the contact for which you requested the details
    */
    'id': number;
    /**
    * Blacklist status for email campaigns (true=blacklisted, false=not blacklisted)
    */
    'emailBlacklisted': boolean;
    /**
    * Blacklist status for SMS campaigns (true=blacklisted, false=not blacklisted)
    */
    'smsBlacklisted': boolean;
    /**
    * Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': string;
    /**
    * Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': string;
    'listIds': Array<number>;
    'listUnsubscribed'?: Array<number>;
    /**
    * Set of attributes of the contact
    */
    'attributes': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "listUnsubscribed",
            "baseName": "listUnsubscribed",
            "type": "Array<number>"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return GetContactDetails.attributeTypeMap;
    }
}

export class GetContacts {
    'contacts': Array<any>;
    /**
    * Number of contacts
    */
    'count': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetContacts.attributeTypeMap;
    }
}

export class GetDeviceBrowserStats {
    /**
    * Number of total clicks for the campaign using the particular browser
    */
    'clickers': number;
    /**
    * Number of unique clicks for the campaign using the particular browser
    */
    'uniqueClicks': number;
    /**
    * Number of openings for the campaign using the particular browser
    */
    'viewed': number;
    /**
    * Number of unique openings for the campaign using the particular browser
    */
    'uniqueViews': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clickers",
            "baseName": "clickers",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "viewed",
            "baseName": "viewed",
            "type": "number"
        },
        {
            "name": "uniqueViews",
            "baseName": "uniqueViews",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetDeviceBrowserStats.attributeTypeMap;
    }
}

export namespace GetEmailCampaign {
}
export class GetEmailCampaigns {
    'campaigns'?: Array<any>;
    /**
    * Number of Email campaigns retrieved
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailCampaigns.attributeTypeMap;
    }
}

export class GetEmailEventReport {
    'events'?: Array<GetEmailEventReportEvents>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<GetEmailEventReportEvents>"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailEventReport.attributeTypeMap;
    }
}

export class GetEmailEventReportEvents {
    /**
    * Email address which generates the event
    */
    'email': string;
    /**
    * UTC date-time on which the event has been generated
    */
    'date': string;
    /**
    * Subject of the event
    */
    'subject'?: string;
    /**
    * Message ID which generated the event
    */
    'messageId': string;
    /**
    * Event which occurred
    */
    'event': GetEmailEventReportEvents.EventEnum;
    /**
    * Reason of bounce (only available if the event is hardbounce or softbounce)
    */
    'reason'?: string;
    /**
    * Tag of the email which generated the event
    */
    'tag'?: string;
    /**
    * IP from which the user has opened the email or clicked on the link (only available if the event is opened or clicks)
    */
    'ip'?: string;
    /**
    * The link which is sent to the user (only available if the event is requests or opened or clicks)
    */
    'link'?: string;
    /**
    * Sender email from which the emails are sent
    */
    'from'?: string;
    /**
    * ID of the template (only available if the email is template based)
    */
    'templateId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "GetEmailEventReportEvents.EventEnum"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetEmailEventReportEvents.attributeTypeMap;
    }
}

export namespace GetEmailEventReportEvents {
    export enum EventEnum {
        Bounces = <any> 'bounces',
        HardBounces = <any> 'hardBounces',
        SoftBounces = <any> 'softBounces',
        Delivered = <any> 'delivered',
        Spam = <any> 'spam',
        Requests = <any> 'requests',
        Opened = <any> 'opened',
        Clicks = <any> 'clicks',
        Invalid = <any> 'invalid',
        Deferred = <any> 'deferred',
        Blocked = <any> 'blocked',
        Unsubscribed = <any> 'unsubscribed',
        Error = <any> 'error'
    }
}
export class GetExtendedCampaignOverview extends GetCampaignOverview {
    /**
    * Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)
    */
    'testSent': boolean;
    /**
    * Header of the campaign
    */
    'header': string;
    /**
    * Footer of the campaign
    */
    'footer': string;
    'sender': GetExtendedCampaignOverviewSender;
    /**
    * Email defined as the \"Reply to\" of the campaign
    */
    'replyTo': string;
    /**
    * Customisation of the \"to\" field of the campaign
    */
    'toField'?: string;
    /**
    * HTML content of the campaign
    */
    'htmlContent': string;
    /**
    * Link to share the campaign on social medias
    */
    'shareLink'?: string;
    /**
    * Tag of the campaign
    */
    'tag'?: string;
    /**
    * Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': string;
    /**
    * UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': string;
    /**
    * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email.
    */
    'inlineImageActivation'?: boolean;
    /**
    * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
    */
    'mirrorActive'?: boolean;
    /**
    * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
    */
    'recurring'?: boolean;
    /**
    * Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if 'status' of the campaign is 'sent'
    */
    'sentDate'?: string;
    /**
    * Total number of non-delivered campaigns for a particular campaign id.
    */
    'returnBounce'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "testSent",
            "baseName": "testSent",
            "type": "boolean"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "GetExtendedCampaignOverviewSender"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "shareLink",
            "baseName": "shareLink",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "recurring",
            "baseName": "recurring",
            "type": "boolean"
        },
        {
            "name": "sentDate",
            "baseName": "sentDate",
            "type": "string"
        },
        {
            "name": "returnBounce",
            "baseName": "returnBounce",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetExtendedCampaignOverview.attributeTypeMap);
    }
}

export class GetEmailCampaign extends GetExtendedCampaignOverview {
    'recipients': GetSmsCampaignRecipients;
    'statistics': GetSmsCampaignRecipients;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "GetSmsCampaignRecipients"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "GetSmsCampaignRecipients"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetEmailCampaign.attributeTypeMap);
    }
}

export namespace GetExtendedCampaignOverview {
}
export class GetExtendedCampaignOverviewSender {
    /**
    * Sender name of the campaign
    */
    'name'?: string;
    /**
    * Sender email of the campaign
    */
    'email'?: string;
    /**
    * Sender id of the campaign
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedCampaignOverviewSender.attributeTypeMap;
    }
}

export class GetExtendedCampaignStats {
    'globalStats': GetExtendedCampaignStatsGlobalStats;
    /**
    * List-wise statistics of the campaign.
    */
    'campaignStats': Array<any>;
    /**
    * Number of clicks on mirror link
    */
    'mirrorClick': number;
    /**
    * Number of remaning emails to send
    */
    'remaining': number;
    /**
    * Statistics about the number of clicks for the links
    */
    'linksStats': any;
    'statsByDomain': GetStatsByDomain;
    /**
    * Statistics about the campaign on the basis of various devices
    */
    'statsByDevice': GetStatsByDevice;
    /**
    * Statistics about the campaign on the basis of various browsers
    */
    'statsByBrowser': GetStatsByBrowser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "globalStats",
            "baseName": "globalStats",
            "type": "GetExtendedCampaignStatsGlobalStats"
        },
        {
            "name": "campaignStats",
            "baseName": "campaignStats",
            "type": "Array<any>"
        },
        {
            "name": "mirrorClick",
            "baseName": "mirrorClick",
            "type": "number"
        },
        {
            "name": "remaining",
            "baseName": "remaining",
            "type": "number"
        },
        {
            "name": "linksStats",
            "baseName": "linksStats",
            "type": "any"
        },
        {
            "name": "statsByDomain",
            "baseName": "statsByDomain",
            "type": "GetStatsByDomain"
        },
        {
            "name": "statsByDevice",
            "baseName": "statsByDevice",
            "type": "GetStatsByDevice"
        },
        {
            "name": "statsByBrowser",
            "baseName": "statsByBrowser",
            "type": "GetStatsByBrowser"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedCampaignStats.attributeTypeMap;
    }
}

/**
* Overall statistics of the campaign
*/
export class GetExtendedCampaignStatsGlobalStats {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetExtendedCampaignStatsGlobalStats.attributeTypeMap;
    }
}

export class GetExtendedClient extends GetClient {
    'address': GetExtendedClientAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "GetExtendedClientAddress"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetExtendedClient.attributeTypeMap);
    }
}

/**
* Address informations
*/
export class GetExtendedClientAddress {
    /**
    * Street information
    */
    'street': string;
    /**
    * City information
    */
    'city': string;
    /**
    * Zip Code information
    */
    'zipCode': string;
    /**
    * Country information
    */
    'country': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "zipCode",
            "baseName": "zipCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedClientAddress.attributeTypeMap;
    }
}

export class GetExtendedContactDetails extends GetContactDetails {
    'statistics': GetExtendedContactDetailsStatistics;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "GetExtendedContactDetailsStatistics"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetExtendedContactDetails.attributeTypeMap);
    }
}

/**
* Campaign statistics of the contact
*/
export class GetExtendedContactDetailsStatistics {
    /**
    * Listing of the sent campaign for the contact
    */
    'messagesSent'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    /**
    * Listing of the hardbounes generated by the contact
    */
    'hardBounces'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    /**
    * Listing of the softbounes generated by the contact
    */
    'softBounces'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    /**
    * Listing of the complaints generated by the contact
    */
    'complaints'?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
    'unsubscriptions'?: GetExtendedContactDetailsStatisticsUnsubscriptions;
    /**
    * Listing of the openings generated by the contact
    */
    'opened'?: Array<GetExtendedContactDetailsStatisticsOpened>;
    /**
    * Listing of the clicks generated by the contact
    */
    'clicked'?: Array<GetExtendedContactDetailsStatisticsClicked>;
    /**
    * Listing of the transactional attributes for the contact
    */
    'transacAttributes'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messagesSent",
            "baseName": "messagesSent",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "complaints",
            "baseName": "complaints",
            "type": "Array<GetExtendedContactDetailsStatisticsMessagesSent>"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "GetExtendedContactDetailsStatisticsUnsubscriptions"
        },
        {
            "name": "opened",
            "baseName": "opened",
            "type": "Array<GetExtendedContactDetailsStatisticsOpened>"
        },
        {
            "name": "clicked",
            "baseName": "clicked",
            "type": "Array<GetExtendedContactDetailsStatisticsClicked>"
        },
        {
            "name": "transacAttributes",
            "baseName": "transacAttributes",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatistics.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsClicked {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * Listing of the clicked links for the campaign
    */
    'links': Array<GetExtendedContactDetailsStatisticsLinks>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<GetExtendedContactDetailsStatisticsLinks>"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsClicked.attributeTypeMap;
    }
}

export class GetAccount extends GetExtendedClient {
    /**
    * Information about your plans and credits
    */
    'plan': Array<GetAccountPlan>;
    'relay': GetAccountRelay;
    'marketingAutomation'?: GetAccountMarketingAutomation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "plan",
            "baseName": "plan",
            "type": "Array<GetAccountPlan>"
        },
        {
            "name": "relay",
            "baseName": "relay",
            "type": "GetAccountRelay"
        },
        {
            "name": "marketingAutomation",
            "baseName": "marketingAutomation",
            "type": "GetAccountMarketingAutomation"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetAccount.attributeTypeMap);
    }
}

export class GetExtendedContactDetailsStatisticsLinks {
    /**
    * Number of clicks on this link for the campaign
    */
    'count': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': string;
    /**
    * IP from which the user has clicked on the link
    */
    'ip': string;
    /**
    * URL of the clicked link
    */
    'url': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsLinks.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsMessagesSent {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsMessagesSent.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsOpened {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * Number of openings for the campaign
    */
    'count': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': string;
    /**
    * IP from which the user has opened the email
    */
    'ip': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsOpened.attributeTypeMap;
    }
}

/**
* Listing of the unsubscription for the contact
*/
export class GetExtendedContactDetailsStatisticsUnsubscriptions {
    /**
    * Contact unsubscribe via unsubscription link in a campaign
    */
    'userUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>;
    /**
    * Contact has been unsubscribed from the administrator
    */
    'adminUnsubscription': Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userUnsubscription",
            "baseName": "userUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>"
        },
        {
            "name": "adminUnsubscription",
            "baseName": "adminUnsubscription",
            "type": "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsUnsubscriptions.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription {
    /**
    * UTC date-time of the event
    */
    'eventTime': string;
    /**
    * IP from which the user has been unsubscribed
    */
    'ip'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription.attributeTypeMap;
    }
}

export class GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription {
    /**
    * ID of the campaign which generated the event
    */
    'campaignId': number;
    /**
    * UTC date-time of the event
    */
    'eventTime': string;
    /**
    * IP from which the user has unsubscribed
    */
    'ip'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "eventTime",
            "baseName": "eventTime",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription.attributeTypeMap;
    }
}

export class GetExtendedListCampaignStats {
    /**
    * ID of the campaign
    */
    'campaignId': number;
    'stats': GetCampaignStats;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaignId",
            "baseName": "campaignId",
            "type": "number"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "GetCampaignStats"
        }    ];

    static getAttributeTypeMap() {
        return GetExtendedListCampaignStats.attributeTypeMap;
    }
}

export class GetFolder {
    /**
    * ID of the folder
    */
    'id': number;
    /**
    * Name of the folder
    */
    'name': string;
    /**
    * Number of blacklisted contacts in the folder
    */
    'totalBlacklisted': number;
    /**
    * Number of contacts in the folder
    */
    'totalSubscribers': number;
    /**
    * Number of unique contacts in the folder
    */
    'uniqueSubscribers': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "totalBlacklisted",
            "baseName": "totalBlacklisted",
            "type": "number"
        },
        {
            "name": "totalSubscribers",
            "baseName": "totalSubscribers",
            "type": "number"
        },
        {
            "name": "uniqueSubscribers",
            "baseName": "uniqueSubscribers",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFolder.attributeTypeMap;
    }
}

export class GetFolderLists {
    'lists'?: Array<any>;
    /**
    * Number of lists in the folder
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFolderLists.attributeTypeMap;
    }
}

export class GetFolders {
    'folders'?: Array<any>;
    /**
    * Number of folders available in your account
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "folders",
            "baseName": "folders",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetFolders.attributeTypeMap;
    }
}

export class GetIp {
    /**
    * ID of the dedicated IP
    */
    'id': number;
    /**
    * Dedicated IP
    */
    'ip': string;
    /**
    * Status of the IP (true=active, false=inactive)
    */
    'active': boolean;
    /**
    * Domain associated to the IP
    */
    'domain': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetIp.attributeTypeMap;
    }
}

export class GetIpFromSender {
    /**
    * ID of the dedicated IP
    */
    'id': number;
    /**
    * Dedicated IP
    */
    'ip': string;
    /**
    * Domain associated to the IP
    */
    'domain': string;
    /**
    * Weight of the IP
    */
    'weight': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetIpFromSender.attributeTypeMap;
    }
}

export class GetIps {
    /**
    * Dedicated IP(s) available on your account
    */
    'ips': Array<GetIp>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<GetIp>"
        }    ];

    static getAttributeTypeMap() {
        return GetIps.attributeTypeMap;
    }
}

export class GetIpsFromSender {
    /**
    * Dedicated IP(s) linked to a sender
    */
    'ips': Array<GetIpFromSender>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<GetIpFromSender>"
        }    ];

    static getAttributeTypeMap() {
        return GetIpsFromSender.attributeTypeMap;
    }
}

export class GetList {
    /**
    * ID of the list
    */
    'id': number;
    /**
    * Name of the list
    */
    'name': string;
    /**
    * Number of blacklisted contacts in the list
    */
    'totalBlacklisted': number;
    /**
    * Number of contacts in the list
    */
    'totalSubscribers': number;
    /**
    * Number of unique contacts in the list
    */
    'uniqueSubscribers': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "totalBlacklisted",
            "baseName": "totalBlacklisted",
            "type": "number"
        },
        {
            "name": "totalSubscribers",
            "baseName": "totalSubscribers",
            "type": "number"
        },
        {
            "name": "uniqueSubscribers",
            "baseName": "uniqueSubscribers",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetList.attributeTypeMap;
    }
}

export class GetLists {
    /**
    * Listing of all the lists available in your account
    */
    'lists'?: Array<any>;
    /**
    * Number of lists in your account
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetLists.attributeTypeMap;
    }
}

export class GetExtendedList extends GetList {
    /**
    * ID of the folder
    */
    'folderId': number;
    /**
    * Creation UTC date-time of the list (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': string;
    'campaignStats'?: Array<GetExtendedListCampaignStats>;
    /**
    * Status telling if the list is dynamic or not (true=dynamic, false=not dynamic)
    */
    'dynamicList'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "campaignStats",
            "baseName": "campaignStats",
            "type": "Array<GetExtendedListCampaignStats>"
        },
        {
            "name": "dynamicList",
            "baseName": "dynamicList",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetExtendedList.attributeTypeMap);
    }
}

export class GetProcess {
    /**
    * Id of the process
    */
    'id': number;
    /**
    * Status of the process
    */
    'status': GetProcess.StatusEnum;
    /**
    * Process name
    */
    'name': string;
    /**
    * URL on which send export the of contacts once the process is completed
    */
    'exportUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetProcess.StatusEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "exportUrl",
            "baseName": "export_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetProcess.attributeTypeMap;
    }
}

export namespace GetProcess {
    export enum StatusEnum {
        Queued = <any> 'queued',
        InProcess = <any> 'in_process',
        Completed = <any> 'completed'
    }
}
export class GetProcesses {
    /**
    * List of processes available on your account
    */
    'processes'?: Array<GetProcess>;
    /**
    * Number of processes available on your account
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processes",
            "baseName": "processes",
            "type": "Array<GetProcess>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetProcesses.attributeTypeMap;
    }
}

export class GetReports {
    'reports'?: Array<GetReportsReports>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reports",
            "baseName": "reports",
            "type": "Array<GetReportsReports>"
        }    ];

    static getAttributeTypeMap() {
        return GetReports.attributeTypeMap;
    }
}

export class GetReportsReports {
    /**
    * Date of the statistics
    */
    'date': string;
    /**
    * Number of requests for the date
    */
    'requests': number;
    /**
    * Number of delivered emails for the date
    */
    'delivered': number;
    /**
    * Number of hardbounces for the date
    */
    'hardBounces': number;
    /**
    * Number of softbounces for the date
    */
    'softBounces': number;
    /**
    * Number of clicks for the date
    */
    'clicks': number;
    /**
    * Number of unique clicks for the date
    */
    'uniqueClicks': number;
    /**
    * Number of openings for the date
    */
    'opens': number;
    /**
    * Number of unique openings for the date
    */
    'uniqueOpens': number;
    /**
    * Number of complaints (spam reports) for the date
    */
    'spamReports': number;
    /**
    * Number of blocked emails for the date
    */
    'blocked': number;
    /**
    * Number of invalid emails for the date
    */
    'invalid': number;
    /**
    * Number of unsubscribed emails for the date
    */
    'unsubscribed': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "number"
        },
        {
            "name": "uniqueClicks",
            "baseName": "uniqueClicks",
            "type": "number"
        },
        {
            "name": "opens",
            "baseName": "opens",
            "type": "number"
        },
        {
            "name": "uniqueOpens",
            "baseName": "uniqueOpens",
            "type": "number"
        },
        {
            "name": "spamReports",
            "baseName": "spamReports",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "invalid",
            "baseName": "invalid",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetReportsReports.attributeTypeMap;
    }
}

export class GetSendersList {
    /**
    * List of the senders available in your account
    */
    'senders'?: Array<GetSendersListSenders>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "senders",
            "baseName": "senders",
            "type": "Array<GetSendersListSenders>"
        }    ];

    static getAttributeTypeMap() {
        return GetSendersList.attributeTypeMap;
    }
}

export class GetSendersListIps {
    /**
    * Dedicated IP available in your account
    */
    'ip': string;
    /**
    * Domain of the IP
    */
    'domain': string;
    /**
    * Weight of the IP for this sender
    */
    'weight': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSendersListIps.attributeTypeMap;
    }
}

export class GetSendersListSenders {
    /**
    * Id of the sender
    */
    'id': number;
    /**
    * From Name associated to the sender
    */
    'name': string;
    /**
    * From Email associated to the sender
    */
    'email': string;
    /**
    * Status of sender (true=activated, false=deactivated)
    */
    'active': boolean;
    /**
    * List of dedicated IP(s) available in the account. This data is displayed only for dedicated IPs
    */
    'ips'?: Array<GetSendersListIps>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<GetSendersListIps>"
        }    ];

    static getAttributeTypeMap() {
        return GetSendersListSenders.attributeTypeMap;
    }
}

export class GetSharedTemplateUrl {
    /**
    * A unique URL for the email campaign or transactional template. This URL can be shared with other Sendinblue users.
    */
    'sharedUrl': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sharedUrl",
            "baseName": "sharedUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSharedTemplateUrl.attributeTypeMap;
    }
}

export namespace GetSmsCampaign {
}
export class GetSmsCampaignOverview {
    /**
    * ID of the SMS Campaign
    */
    'id': number;
    /**
    * Name of the SMS Campaign
    */
    'name': string;
    /**
    * Status of the SMS Campaign
    */
    'status': GetSmsCampaignOverview.StatusEnum;
    /**
    * Content of the SMS Campaign
    */
    'content': string;
    /**
    * UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
    */
    'scheduledAt'?: string;
    /**
    * Sender of the SMS Campaign
    */
    'sender': string;
    /**
    * Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': string;
    /**
    * UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "GetSmsCampaignOverview.StatusEnum"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaignOverview.attributeTypeMap;
    }
}

export class GetSmsCampaign extends GetSmsCampaignOverview {
    'recipients': GetSmsCampaignRecipients;
    'statistics': GetSmsCampaignRecipients;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "GetSmsCampaignRecipients"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "GetSmsCampaignRecipients"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetSmsCampaign.attributeTypeMap);
    }
}

export namespace GetSmsCampaignOverview {
    export enum StatusEnum {
        Draft = <any> 'draft',
        Sent = <any> 'sent',
        Archive = <any> 'archive',
        Queued = <any> 'queued',
        Suspended = <any> 'suspended',
        InProcess = <any> 'inProcess'
    }
}
export class GetSmsCampaignRecipients {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GetSmsCampaignRecipients.attributeTypeMap;
    }
}

export class GetSmsCampaignStats {
    /**
    * Number of delivered SMS
    */
    'delivered': number;
    /**
    * Number of sent SMS
    */
    'sent': number;
    /**
    * Number of processing SMS
    */
    'processing': number;
    /**
    * Number of softbounced SMS
    */
    'softBounces': number;
    /**
    * Number of hardbounced SMS
    */
    'hardBounces': number;
    /**
    * Number of unsubscription SMS
    */
    'unsubscriptions': number;
    /**
    * Number of replies to the SMS
    */
    'answered': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "sent",
            "baseName": "sent",
            "type": "number"
        },
        {
            "name": "processing",
            "baseName": "processing",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "unsubscriptions",
            "baseName": "unsubscriptions",
            "type": "number"
        },
        {
            "name": "answered",
            "baseName": "answered",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaignStats.attributeTypeMap;
    }
}

export class GetSmsCampaigns {
    'campaigns'?: Array<any>;
    /**
    * Number of SMS campaigns retrieved
    */
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<any>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsCampaigns.attributeTypeMap;
    }
}

export class GetSmsEventReport {
    'events'?: Array<GetSmsEventReportEvents>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<GetSmsEventReportEvents>"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsEventReport.attributeTypeMap;
    }
}

export class GetSmsEventReportEvents {
    /**
    * Phone number which has generated the event
    */
    'phoneNumber'?: string;
    /**
    * UTC date-time on which the event has been generated
    */
    'date'?: string;
    /**
    * Message ID which generated the event
    */
    'messageId'?: string;
    /**
    * Event which occurred
    */
    'event'?: GetSmsEventReportEvents.EventEnum;
    /**
    * Reason of bounce (only available if the event is hardbounce or softbounce)
    */
    'reason'?: string;
    'reply'?: string;
    /**
    * Tag of the SMS which generated the event
    */
    'tag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "GetSmsEventReportEvents.EventEnum"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "reply",
            "baseName": "reply",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSmsEventReportEvents.attributeTypeMap;
    }
}

export namespace GetSmsEventReportEvents {
    export enum EventEnum {
        Bounces = <any> 'bounces',
        HardBounces = <any> 'hardBounces',
        SoftBounces = <any> 'softBounces',
        Delivered = <any> 'delivered',
        Sent = <any> 'sent',
        Accepted = <any> 'accepted',
        Unsubscription = <any> 'unsubscription',
        Replies = <any> 'replies',
        Blocked = <any> 'blocked'
    }
}
export class GetSmtpTemplateOverview {
    /**
    * ID of the template
    */
    'id': number;
    /**
    * Name of the template
    */
    'name': string;
    /**
    * Subject of the template
    */
    'subject': string;
    /**
    * Status of template (true=active, false=inactive)
    */
    'isActive': boolean;
    /**
    * Status of test sending for the template (true=test email has been sent, false=test email has not been sent)
    */
    'testSent': boolean;
    'sender': GetSmtpTemplateOverviewSender;
    /**
    * Email defined as the \"Reply to\" for the template
    */
    'replyTo': string;
    /**
    * Customisation of the \"to\" field for the template
    */
    'toField': string;
    /**
    * Tag of the template
    */
    'tag': string;
    /**
    * HTML content of the template
    */
    'htmlContent': string;
    /**
    * Creation UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': string;
    /**
    * Last modification UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': string;
    /**
    * It is true if template is a valid Double opt-in (DOI) template, otherwise it is false. This field will be available only in case of single template detail call.
    */
    'doiTemplate'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        },
        {
            "name": "testSent",
            "baseName": "testSent",
            "type": "boolean"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "GetSmtpTemplateOverviewSender"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        },
        {
            "name": "doiTemplate",
            "baseName": "doiTemplate",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GetSmtpTemplateOverview.attributeTypeMap;
    }
}

export class GetSmtpTemplateOverviewSender {
    /**
    * From email for the template
    */
    'name'?: string;
    /**
    * From email for the template
    */
    'email'?: string;
    /**
    * Sender id of the template
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSmtpTemplateOverviewSender.attributeTypeMap;
    }
}

export class GetSmtpTemplates {
    /**
    * Count of transactional email templates
    */
    'count'?: number;
    'templates'?: Array<GetSmtpTemplateOverview>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "templates",
            "baseName": "templates",
            "type": "Array<GetSmtpTemplateOverview>"
        }    ];

    static getAttributeTypeMap() {
        return GetSmtpTemplates.attributeTypeMap;
    }
}

export class GetSsoToken {
    /**
    * Session token. It will remain valid for a short period of time only.
    */
    'token': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSsoToken.attributeTypeMap;
    }
}

export class GetStatsByBrowser extends null<string, GetDeviceBrowserStats> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetStatsByBrowser.attributeTypeMap);
    }
}

export class GetStatsByDevice {
    /**
    * Statistics of the campaign on the basis of desktop devices
    */
    'desktop'?: { [key: string]: GetDeviceBrowserStats; };
    /**
    * Statistics of the campaign on the basis of mobile devices
    */
    'mobile'?: { [key: string]: GetDeviceBrowserStats; };
    /**
    * Statistics of the campaign on the basis of tablet devices
    */
    'tablet'?: { [key: string]: GetDeviceBrowserStats; };
    /**
    * Statistics of the campaign on the basis of unknown devices
    */
    'unknown'?: { [key: string]: GetDeviceBrowserStats; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "desktop",
            "baseName": "desktop",
            "type": "{ [key: string]: GetDeviceBrowserStats; }"
        },
        {
            "name": "mobile",
            "baseName": "mobile",
            "type": "{ [key: string]: GetDeviceBrowserStats; }"
        },
        {
            "name": "tablet",
            "baseName": "tablet",
            "type": "{ [key: string]: GetDeviceBrowserStats; }"
        },
        {
            "name": "unknown",
            "baseName": "unknown",
            "type": "{ [key: string]: GetDeviceBrowserStats; }"
        }    ];

    static getAttributeTypeMap() {
        return GetStatsByDevice.attributeTypeMap;
    }
}

export class GetStatsByDomain extends null<string, GetCampaignStats> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GetStatsByDomain.attributeTypeMap);
    }
}

export class GetTransacAggregatedSmsReport {
    /**
    * Time frame of the report
    */
    'range'?: string;
    /**
    * Number of requests for the timeframe
    */
    'requests'?: number;
    /**
    * Number of delivered SMS for the timeframe
    */
    'delivered'?: number;
    /**
    * Number of hardbounces for the timeframe
    */
    'hardBounces'?: number;
    /**
    * Number of softbounces for the timeframe
    */
    'softBounces'?: number;
    /**
    * Number of blocked contact for the timeframe
    */
    'blocked'?: number;
    /**
    * Number of unsubscription for the timeframe
    */
    'unsubscribed'?: number;
    /**
    * Number of answered SMS for the timeframe
    */
    'replied'?: number;
    /**
    * Number of accepted for the timeframe
    */
    'accepted'?: number;
    /**
    * Number of rejected for the timeframe
    */
    'rejected'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "range",
            "baseName": "range",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        },
        {
            "name": "replied",
            "baseName": "replied",
            "type": "number"
        },
        {
            "name": "accepted",
            "baseName": "accepted",
            "type": "number"
        },
        {
            "name": "rejected",
            "baseName": "rejected",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacAggregatedSmsReport.attributeTypeMap;
    }
}

export class GetTransacBlockedContacts {
    /**
    * Count of blocked or unsubscribed contact
    */
    'count'?: number;
    'contacts'?: Array<GetTransacBlockedContactsContacts>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "Array<GetTransacBlockedContactsContacts>"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacBlockedContacts.attributeTypeMap;
    }
}

export class GetTransacBlockedContactsContacts {
    /**
    * Email address of the blocked or unsubscribed contact
    */
    'email': string;
    /**
    * Sender email address of the blocked or unsubscribed contact
    */
    'senderEmail': string;
    'reason': GetTransacBlockedContactsReason;
    /**
    * Date when the contact was blocked or unsubscribed on
    */
    'blockedAt': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "senderEmail",
            "baseName": "senderEmail",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "GetTransacBlockedContactsReason"
        },
        {
            "name": "blockedAt",
            "baseName": "blockedAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacBlockedContactsContacts.attributeTypeMap;
    }
}

/**
* Reason for blocking / unsubscribing
*/
export class GetTransacBlockedContactsReason {
    /**
    * Reason code for blocking / unsubscribing (This code is safe for comparison)
    */
    'code'?: GetTransacBlockedContactsReason.CodeEnum;
    /**
    * Reason for blocking / unsubscribing (This string is not safe for comparison)
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "GetTransacBlockedContactsReason.CodeEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacBlockedContactsReason.attributeTypeMap;
    }
}

export namespace GetTransacBlockedContactsReason {
    export enum CodeEnum {
        UnsubscribedViaMA = <any> 'unsubscribedViaMA',
        UnsubscribedViaEmail = <any> 'unsubscribedViaEmail',
        AdminBlocked = <any> 'adminBlocked',
        UnsubscribedViaApi = <any> 'unsubscribedViaApi',
        HardBounce = <any> 'hardBounce',
        ContactFlaggedAsSpam = <any> 'contactFlaggedAsSpam'
    }
}
export class GetTransacEmailContent {
    /**
    * Email address to which transactional email has been sent
    */
    'email': string;
    /**
    * Subject of the sent email
    */
    'subject': string;
    /**
    * Id of the template
    */
    'templateId'?: number;
    /**
    * Date on which transactional email was sent
    */
    'date': string;
    /**
    * Series of events which occurred on the transactional email
    */
    'events': Array<GetTransacEmailContentEvents>;
    /**
    * Actual content of the transactional email that has been sent
    */
    'body': string;
    /**
    * Count of the attachments that were sent in the email
    */
    'attachmentCount': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<GetTransacEmailContentEvents>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "attachmentCount",
            "baseName": "attachmentCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailContent.attributeTypeMap;
    }
}

export class GetTransacEmailContentEvents {
    /**
    * Name of the event that occurred on the sent email
    */
    'name': string;
    /**
    * Time at which the event occurred
    */
    'time': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailContentEvents.attributeTypeMap;
    }
}

export class GetTransacEmailsList {
    'transactionalEmails'?: Array<GetTransacEmailsListTransactionalEmails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionalEmails",
            "baseName": "transactionalEmails",
            "type": "Array<GetTransacEmailsListTransactionalEmails>"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailsList.attributeTypeMap;
    }
}

export class GetTransacEmailsListTransactionalEmails {
    /**
    * Email address to which transactional email has been sent
    */
    'email': string;
    /**
    * Subject of the sent email
    */
    'subject': string;
    /**
    * Id of the template
    */
    'templateId'?: number;
    /**
    * Message Id of the sent email
    */
    'messageId': string;
    /**
    * Unique id of the email sent to a particular contact
    */
    'uuid': string;
    /**
    * Date on which transactional email was sent
    */
    'date': string;
    /**
    * Email address of the sender from which the email was sent
    */
    'from'?: string;
    /**
    * Tags used for your email
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacEmailsListTransactionalEmails.attributeTypeMap;
    }
}

export class GetTransacSmsReport {
    'reports'?: Array<GetTransacSmsReportReports>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reports",
            "baseName": "reports",
            "type": "Array<GetTransacSmsReportReports>"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacSmsReport.attributeTypeMap;
    }
}

export class GetTransacSmsReportReports {
    /**
    * Date for which statistics are retrieved
    */
    'date'?: string;
    /**
    * Number of requests for the date
    */
    'requests'?: number;
    /**
    * Number of delivered SMS for the date
    */
    'delivered'?: number;
    /**
    * Number of hardbounces for the date
    */
    'hardBounces'?: number;
    /**
    * Number of softbounces for the date
    */
    'softBounces'?: number;
    /**
    * Number of blocked contact for the date
    */
    'blocked'?: number;
    /**
    * Number of unsubscription for the date
    */
    'unsubscribed'?: number;
    /**
    * Number of answered SMS for the date
    */
    'replied'?: number;
    /**
    * Number of accepted for the date
    */
    'accepted'?: number;
    /**
    * Number of rejected for the date
    */
    'rejected'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "requests",
            "baseName": "requests",
            "type": "number"
        },
        {
            "name": "delivered",
            "baseName": "delivered",
            "type": "number"
        },
        {
            "name": "hardBounces",
            "baseName": "hardBounces",
            "type": "number"
        },
        {
            "name": "softBounces",
            "baseName": "softBounces",
            "type": "number"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "number"
        },
        {
            "name": "unsubscribed",
            "baseName": "unsubscribed",
            "type": "number"
        },
        {
            "name": "replied",
            "baseName": "replied",
            "type": "number"
        },
        {
            "name": "accepted",
            "baseName": "accepted",
            "type": "number"
        },
        {
            "name": "rejected",
            "baseName": "rejected",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GetTransacSmsReportReports.attributeTypeMap;
    }
}

export class GetWebhook {
    /**
    * URL of the webhook
    */
    'url': string;
    /**
    * ID of the webhook
    */
    'id': number;
    /**
    * Description of the webhook
    */
    'description': string;
    'events': Array<string>;
    /**
    * Type of webhook (marketing or transac)
    */
    'type': GetWebhook.TypeEnum;
    /**
    * Creation UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'createdAt': string;
    /**
    * Last modification UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
    */
    'modifiedAt': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<string>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "GetWebhook.TypeEnum"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetWebhook.attributeTypeMap;
    }
}

export namespace GetWebhook {
    export enum TypeEnum {
        Marketing = <any> 'marketing',
        Transac = <any> 'transac'
    }
}
export class GetWebhooks {
    'webhooks': Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhooks",
            "baseName": "webhooks",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return GetWebhooks.attributeTypeMap;
    }
}

export class ManageIp {
    /**
    * Dedicated ID
    */
    'ip'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ManageIp.attributeTypeMap;
    }
}

export class PostContactInfo {
    'contacts': PostContactInfoContacts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contacts",
            "baseName": "contacts",
            "type": "PostContactInfoContacts"
        }    ];

    static getAttributeTypeMap() {
        return PostContactInfo.attributeTypeMap;
    }
}

export class PostContactInfoContacts {
    'success'?: Array<string>;
    'failure'?: Array<string>;
    /**
    * Displays the count of total number of contacts removed from list when user opts for \"all\" option.
    */
    'total'?: number;
    /**
    * Id of the process created to remove contacts from list when user opts for \"all\" option.
    */
    'processId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "Array<string>"
        },
        {
            "name": "failure",
            "baseName": "failure",
            "type": "Array<string>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "processId",
            "baseName": "processId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostContactInfoContacts.attributeTypeMap;
    }
}

export class PostSendFailed {
    /**
    * Response code
    */
    'code': number;
    /**
    * Response message
    */
    'message': string;
    'unexistingEmails'?: Array<string>;
    'withoutListEmails'?: Array<string>;
    'blackListedEmails'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "unexistingEmails",
            "baseName": "unexistingEmails",
            "type": "Array<string>"
        },
        {
            "name": "withoutListEmails",
            "baseName": "withoutListEmails",
            "type": "Array<string>"
        },
        {
            "name": "blackListedEmails",
            "baseName": "blackListedEmails",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PostSendFailed.attributeTypeMap;
    }
}

export class PostSendSmsTestFailed {
    /**
    * Response code
    */
    'code': number;
    /**
    * Response message
    */
    'message': string;
    'unexistingSms'?: Array<string>;
    'withoutListSms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "unexistingSms",
            "baseName": "unexistingSms",
            "type": "Array<string>"
        },
        {
            "name": "withoutListSms",
            "baseName": "withoutListSms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PostSendSmsTestFailed.attributeTypeMap;
    }
}

export class RemainingCreditModel {
    'child': RemainingCreditModelChild;
    'reseller': RemainingCreditModelReseller;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "child",
            "baseName": "child",
            "type": "RemainingCreditModelChild"
        },
        {
            "name": "reseller",
            "baseName": "reseller",
            "type": "RemainingCreditModelReseller"
        }    ];

    static getAttributeTypeMap() {
        return RemainingCreditModel.attributeTypeMap;
    }
}

/**
* Credits remaining for child account
*/
export class RemainingCreditModelChild {
    /**
    * SMS Credits remaining for child account
    */
    'sms': number;
    /**
    * Email Credits remaining for child account
    */
    'email': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RemainingCreditModelChild.attributeTypeMap;
    }
}

export class RemainingCreditModelReseller {
    /**
    * SMS Credits remaining for reseller account
    */
    'sms': number;
    /**
    * Email Credits remaining for reseller account
    */
    'email': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RemainingCreditModelReseller.attributeTypeMap;
    }
}

export class RemoveContactFromList {
    /**
    * Required if 'all' is false. Emails to remove from a list. You can pass a maximum of 150 emails for removal in one request.
    */
    'emails'?: Array<string>;
    /**
    * Mandatory if Emails are not passed, ignored otherwise. Emails to add to a list. You can pass a maximum of 150 emails for addition in one request. If you need to add the emails in bulk, please prefer /contacts/import api.
    */
    'ids'?: Array<number>;
    /**
    * Required if none of 'emails' or 'ids' are passed. Remove all existing contacts from a list.  A process will be created in this scenario. You can fetch the process details to know about the progress
    */
    'all'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        },
        {
            "name": "ids",
            "baseName": "ids",
            "type": "Array<number>"
        },
        {
            "name": "all",
            "baseName": "all",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RemoveContactFromList.attributeTypeMap;
    }
}

export class RemoveCredits {
    /**
    * Required if email credits are empty. SMS credits to be removed from the child account
    */
    'sms'?: number;
    /**
    * Required if sms credits are empty. Email credits to be removed from the child account
    */
    'email'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sms",
            "baseName": "sms",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RemoveCredits.attributeTypeMap;
    }
}

export class RequestContactExport {
    /**
    * List of all the attributes that you want to export. These attributes must be present in your contact database. For example, ['fname', 'lname', 'email'].
    */
    'exportAttributes'?: Array<string>;
    /**
    * This attribute has been deprecated and will be removed by January 1st, 2021. Only one of the two filter options (contactFilter or customContactFilter) can be passed in the request. Set the filter for the contacts to be exported. For example, {\"blacklisted\":true} will export all the blacklisted contacts. 
    */
    'contactFilter'?: any;
    'customContactFilter'?: RequestContactExportCustomContactFilter;
    /**
    * Webhook that will be called once the export process is finished. For reference, https://help.sendinblue.com/hc/en-us/articles/360007666479
    */
    'notifyUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exportAttributes",
            "baseName": "exportAttributes",
            "type": "Array<string>"
        },
        {
            "name": "contactFilter",
            "baseName": "contactFilter",
            "type": "any"
        },
        {
            "name": "customContactFilter",
            "baseName": "customContactFilter",
            "type": "RequestContactExportCustomContactFilter"
        },
        {
            "name": "notifyUrl",
            "baseName": "notifyUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactExport.attributeTypeMap;
    }
}

/**
* Only one of the two filter options (contactFilter or customContactFilter) can be passed in the request. Set the filter for the contacts to be exported.
*/
export class RequestContactExportCustomContactFilter {
    /**
    * Mandatory if neither actionForEmailCampaigns nor actionForSmsCampaigns is passed. This will export the contacts on the basis of provided action applied on contacts as per the list id. * allContacts - Fetch the list of all contacts for a particular list. * subscribed & unsubscribed - Fetch the list of subscribed / unsubscribed (blacklisted via any means) contacts for a particular list. * unsubscribedPerList - Fetch the list of contacts that are unsubscribed from a particular list only. 
    */
    'actionForContacts'?: RequestContactExportCustomContactFilter.ActionForContactsEnum;
    /**
    * Mandatory if neither actionForContacts nor actionForSmsCampaigns is passed. This will export the contacts on the basis of provided action applied on email campaigns. * openers & nonOpeners - emailCampaignId is mandatory. Fetch the list of readers / non-readers for a particular email campaign. * clickers & nonClickers - emailCampaignId is mandatory. Fetch the list of clickers / non-clickers for a particular email campaign. * unsubscribed - emailCampaignId is mandatory. Fetch the list of all unsubscribed (blacklisted via any means) contacts for a particular email campaign. * hardBounces & softBounces - emailCampaignId is optional. Fetch the list of hard bounces / soft bounces for a particular / all email campaign(s). 
    */
    'actionForEmailCampaigns'?: RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum;
    /**
    * Mandatory if neither actionForContacts nor actionForEmailCampaigns is passed. This will export the contacts on the basis of provided action applied on sms campaigns. * unsubscribed - Fetch the list of all unsubscribed (blacklisted via any means) contacts for all / particular sms campaigns. * hardBounces & softBounces - Fetch the list of hard bounces / soft bounces for all / particular sms campaigns. 
    */
    'actionForSmsCampaigns'?: RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum;
    /**
    * Mandatory if actionForContacts is passed, ignored otherwise. Id of the list for which the corresponding action shall be applied in the filter.
    */
    'listId'?: number;
    /**
    * Considered only if actionForEmailCampaigns is passed, ignored otherwise. Mandatory if action is one of the following - openers, nonOpeners, clickers, nonClickers, unsubscribed. The id of the email campaign for which the corresponding action shall be applied in the filter.
    */
    'emailCampaignId'?: number;
    /**
    * Considered only if actionForSmsCampaigns is passed, ignored otherwise. The id of sms campaign for which the corresponding action shall be applied in the filter.
    */
    'smsCampaignId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionForContacts",
            "baseName": "actionForContacts",
            "type": "RequestContactExportCustomContactFilter.ActionForContactsEnum"
        },
        {
            "name": "actionForEmailCampaigns",
            "baseName": "actionForEmailCampaigns",
            "type": "RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum"
        },
        {
            "name": "actionForSmsCampaigns",
            "baseName": "actionForSmsCampaigns",
            "type": "RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum"
        },
        {
            "name": "listId",
            "baseName": "listId",
            "type": "number"
        },
        {
            "name": "emailCampaignId",
            "baseName": "emailCampaignId",
            "type": "number"
        },
        {
            "name": "smsCampaignId",
            "baseName": "smsCampaignId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactExportCustomContactFilter.attributeTypeMap;
    }
}

export namespace RequestContactExportCustomContactFilter {
    export enum ActionForContactsEnum {
        AllContacts = <any> 'allContacts',
        Subscribed = <any> 'subscribed',
        Unsubscribed = <any> 'unsubscribed',
        UnsubscribedPerList = <any> 'unsubscribedPerList'
    }
    export enum ActionForEmailCampaignsEnum {
        Openers = <any> 'openers',
        NonOpeners = <any> 'nonOpeners',
        Clickers = <any> 'clickers',
        NonClickers = <any> 'nonClickers',
        Unsubscribed = <any> 'unsubscribed',
        HardBounces = <any> 'hardBounces',
        SoftBounces = <any> 'softBounces'
    }
    export enum ActionForSmsCampaignsEnum {
        HardBounces = <any> 'hardBounces',
        SoftBounces = <any> 'softBounces',
        Unsubscribed = <any> 'unsubscribed'
    }
}
export class RequestContactImport {
    /**
    * Mandatory if fileBody is not defined. URL of the file to be imported (no local file). Possible file formats: .txt, .csv
    */
    'fileUrl'?: string;
    /**
    * Mandatory if fileUrl is not defined. CSV content to be imported. Use semicolon to separate multiple attributes. Maximum allowed file body size is 10MB . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of file body size while parsing. Please use fileUrl instead to import bigger files.
    */
    'fileBody'?: string;
    /**
    * Mandatory if newList is not defined. Ids of the lists in which the contacts shall be imported. For example, [2, 4, 7].
    */
    'listIds'?: Array<number>;
    /**
    * URL that will be called once the import process is finished. For reference, https://help.sendinblue.com/hc/en-us/articles/360007666479
    */
    'notifyUrl'?: string;
    'newList'?: RequestContactImportNewList;
    /**
    * To blacklist all the contacts for email
    */
    'emailBlacklist'?: boolean;
    /**
    * To blacklist all the contacts for sms
    */
    'smsBlacklist'?: boolean;
    /**
    * To facilitate the choice to update the existing contacts
    */
    'updateExistingContacts'?: boolean;
    /**
    * To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes = true means the empty fields in your import will erase any attribute that currently contain data in SendinBlue, & emptyContactsAttributes = false means the empty fields will not affect your existing data ( only available if `updateExistingContacts` set to true )
    */
    'emptyContactsAttributes'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileUrl",
            "baseName": "fileUrl",
            "type": "string"
        },
        {
            "name": "fileBody",
            "baseName": "fileBody",
            "type": "string"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "notifyUrl",
            "baseName": "notifyUrl",
            "type": "string"
        },
        {
            "name": "newList",
            "baseName": "newList",
            "type": "RequestContactImportNewList"
        },
        {
            "name": "emailBlacklist",
            "baseName": "emailBlacklist",
            "type": "boolean"
        },
        {
            "name": "smsBlacklist",
            "baseName": "smsBlacklist",
            "type": "boolean"
        },
        {
            "name": "updateExistingContacts",
            "baseName": "updateExistingContacts",
            "type": "boolean"
        },
        {
            "name": "emptyContactsAttributes",
            "baseName": "emptyContactsAttributes",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactImport.attributeTypeMap;
    }
}

/**
* To create a new list and import the contacts into it, pass the listName and an optional folderId.
*/
export class RequestContactImportNewList {
    /**
    * List with listName will be created first and users will be imported in it (Mandatory if listIds is empty).
    */
    'listName'?: string;
    /**
    * Id of the folder where this new list shall be created (Mandatory if listName is not empty).
    */
    'folderId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listName",
            "baseName": "listName",
            "type": "string"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RequestContactImportNewList.attributeTypeMap;
    }
}

export class RequestSmsRecipientExport {
    /**
    * URL that will be called once the export process is finished. For reference, https://help.sendinblue.com/hc/en-us/articles/360007666479
    */
    'notifyURL'?: string;
    /**
    * Filter the recipients based on how they interacted with the campaign
    */
    'recipientsType': RequestSmsRecipientExport.RecipientsTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifyURL",
            "baseName": "notifyURL",
            "type": "string"
        },
        {
            "name": "recipientsType",
            "baseName": "recipientsType",
            "type": "RequestSmsRecipientExport.RecipientsTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return RequestSmsRecipientExport.attributeTypeMap;
    }
}

export namespace RequestSmsRecipientExport {
    export enum RecipientsTypeEnum {
        All = <any> 'all',
        Delivered = <any> 'delivered',
        Answered = <any> 'answered',
        SoftBounces = <any> 'softBounces',
        HardBounces = <any> 'hardBounces',
        Unsubscribed = <any> 'unsubscribed'
    }
}
export class SendEmail {
    /**
    * List of the email addresses of the recipients. For example, ['abc@example.com', 'asd@example.com'].
    */
    'emailTo': Array<string>;
    /**
    * List of the email addresses of the recipients in bcc
    */
    'emailBcc'?: Array<string>;
    /**
    * List of the email addresses of the recipients in cc
    */
    'emailCc'?: Array<string>;
    /**
    * Email address which shall be used by campaign recipients to reply back
    */
    'replyTo'?: string;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl'?: string;
    /**
    * Pass the list of content (base64 encoded) and name of the attachment. For example, [{\"content\":\"base64 encoded content 1\", \"name\":\"attcahment1\"}, {\"content\":\"base64 encoded content 2\", \"name\":\"attcahment2\"}].
    */
    'attachment'?: Array<SendEmailAttachment>;
    /**
    * Pass the set of headers that shall be sent along the mail headers in the original email. 'sender.ip' header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. Headers are allowed in `This-Case-Only` (i.e. words separated by hyphen with first letter of each word in capital letter), they will be converted to such case styling if not in this format in the request payload. For example, {\"Content-Type\":\"text/html\", \"charset\":\"iso-8859-1\", \"sender.ip\":\"1.2.3.4\"}
    */
    'headers'?: any;
    /**
    * Pass the set of attributes to customize the template. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}
    */
    'attributes'?: any;
    /**
    * Tag your emails to find them more easily
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailTo",
            "baseName": "emailTo",
            "type": "Array<string>"
        },
        {
            "name": "emailBcc",
            "baseName": "emailBcc",
            "type": "Array<string>"
        },
        {
            "name": "emailCc",
            "baseName": "emailCc",
            "type": "Array<string>"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Array<SendEmailAttachment>"
        },
        {
            "name": "headers",
            "baseName": "headers",
            "type": "any"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendEmail.attributeTypeMap;
    }
}

export class SendEmailAttachment {
    /**
    * Base64 encoded chunk data of the attachment generated on the fly
    */
    'content': string;
    /**
    * Required for content. Name of the attachment
    */
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendEmailAttachment.attributeTypeMap;
    }
}

export class SendReport {
    /**
    * Language of email content for campaign report sending.
    */
    'language'?: SendReport.LanguageEnum;
    'email': SendReportEmail;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "language",
            "baseName": "language",
            "type": "SendReport.LanguageEnum"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "SendReportEmail"
        }    ];

    static getAttributeTypeMap() {
        return SendReport.attributeTypeMap;
    }
}

export namespace SendReport {
    export enum LanguageEnum {
        Fr = <any> 'fr',
        Es = <any> 'es',
        Pt = <any> 'pt',
        It = <any> 'it',
        De = <any> 'de',
        En = <any> 'en'
    }
}
/**
* Custom attributes for the report email.
*/
export class SendReportEmail {
    /**
    * Email addresses of the recipients
    */
    'to': Array<string>;
    /**
    * Custom text message to be presented in the report email.
    */
    'body': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<string>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendReportEmail.attributeTypeMap;
    }
}

export class SendSms {
    'reference': string;
    'messageId': number;
    /**
    * Count of SMS's to send multiple text messages
    */
    'smsCount'?: number;
    /**
    * SMS credits used per text message
    */
    'usedCredits'?: number;
    /**
    * Remaining SMS credits of the user
    */
    'remainingCredits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "number"
        },
        {
            "name": "smsCount",
            "baseName": "smsCount",
            "type": "number"
        },
        {
            "name": "usedCredits",
            "baseName": "usedCredits",
            "type": "number"
        },
        {
            "name": "remainingCredits",
            "baseName": "remainingCredits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SendSms.attributeTypeMap;
    }
}

export class SendSmtpEmail {
    'sender'?: SendSmtpEmailSender;
    /**
    * Mandatory if messageVersions are not passed, ignored if messageVersions are passed. List of email addresses and names (optional) of the recipients. For example, [{\"name\":\"Jimmy\", \"email\":\"jimmy98@example.com\"}, {\"name\":\"Joe\", \"email\":\"joe@example.com\"}]
    */
    'to'?: Array<SendSmtpEmailTo>;
    /**
    * List of email addresses and names (optional) of the recipients in bcc
    */
    'bcc'?: Array<SendSmtpEmailBcc>;
    /**
    * List of email addresses and names (optional) of the recipients in cc
    */
    'cc'?: Array<SendSmtpEmailCc>;
    /**
    * HTML body of the message ( Mandatory if 'templateId' is not passed, ignored if 'templateId' is passed )
    */
    'htmlContent'?: string;
    /**
    * Plain Text body of the message ( Ignored if 'templateId' is passed )
    */
    'textContent'?: string;
    /**
    * Subject of the message. Mandatory if 'templateId' is not passed
    */
    'subject'?: string;
    'replyTo'?: SendSmtpEmailReplyTo;
    /**
    * Pass the absolute URL (no local file) or the base64 content of the attachment along with the attachment name (Mandatory if attachment content is passed). For example, `[{\"url\":\"https://attachment.domain.com/myAttachmentFromUrl.jpg\", \"name\":\"myAttachmentFromUrl.jpg\"}, {\"content\":\"base64 example content\", \"name\":\"myAttachmentFromBase64.jpg\"}]`. Allowed extensions for attachment file: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg and wmv ( If 'templateId' is passed and is in New Template Language format then both attachment url and content are accepted. If template is in Old template Language format, then 'attachment' is ignored )
    */
    'attachment'?: Array<SendSmtpEmailAttachment>;
    /**
    * Pass the set of custom headers (not the standard headers) that shall be sent along the mail headers in the original email. 'sender.ip' header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. Headers are allowed in `This-Case-Only` (i.e. words separated by hyphen with first letter of each word in capital letter), they will be converted to such case styling if not in this format in the request payload. For example, `{\"sender.ip\":\"1.2.3.4\", \"X-Mailin-custom\":\"some_custom_header\"}`.
    */
    'headers'?: any;
    /**
    * Id of the template. Mandatory if messageVersions are passed
    */
    'templateId'?: number;
    /**
    * Pass the set of attributes to customize the template. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. It's considered only if template is in New Template Language format.
    */
    'params'?: any;
    /**
    * You can customize and send out multiple versions of a templateId. Some global parameters such as **to(mandatory), bcc, cc, replyTo, subject** can also be customized specific to each version. The size of individual params in all the messageVersions shall not exceed 100 KB limit and that of cumulative params shall not exceed 1000 KB. This feature is currently in its beta version. You can follow this **step-by-step guide** on how to use **messageVersions** to batch send emails - https://developers.sendinblue.com/docs/batch-send-transactional-emails
    */
    'messageVersions'?: Array<SendSmtpEmailMessageVersions>;
    /**
    * Tag your emails to find them more easily
    */
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sender",
            "baseName": "sender",
            "type": "SendSmtpEmailSender"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<SendSmtpEmailTo>"
        },
        {
            "name": "bcc",
            "baseName": "bcc",
            "type": "Array<SendSmtpEmailBcc>"
        },
        {
            "name": "cc",
            "baseName": "cc",
            "type": "Array<SendSmtpEmailCc>"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "textContent",
            "baseName": "textContent",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "SendSmtpEmailReplyTo"
        },
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Array<SendSmtpEmailAttachment>"
        },
        {
            "name": "headers",
            "baseName": "headers",
            "type": "any"
        },
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "number"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        },
        {
            "name": "messageVersions",
            "baseName": "messageVersions",
            "type": "Array<SendSmtpEmailMessageVersions>"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmail.attributeTypeMap;
    }
}

export class SendSmtpEmailAttachment {
    /**
    * Absolute url of the attachment (no local file).
    */
    'url'?: string;
    /**
    * Base64 encoded chunk data of the attachment generated on the fly
    */
    'content'?: string;
    /**
    * Required if content is passed. Name of the attachment
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailAttachment.attributeTypeMap;
    }
}

export class SendSmtpEmailBcc {
    /**
    * Email address of the recipient in bcc
    */
    'email': string;
    /**
    * Name of the recipient in bcc. Maximum allowed characters are 70.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailBcc.attributeTypeMap;
    }
}

export class SendSmtpEmailCc {
    /**
    * Email address of the recipient in cc
    */
    'email': string;
    /**
    * Name of the recipient in cc. Maximum allowed characters are 70.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailCc.attributeTypeMap;
    }
}

export class SendSmtpEmailMessageVersions {
    /**
    * List of email addresses and names (_optional_) of the recipients. For example, [{\"name\":\"Jimmy\", \"email\":\"jimmy98@example.com\"}, {\"name\":\"Joe\", \"email\":\"joe@example.com\"}]
    */
    'to': Array<SendSmtpEmailTo1>;
    /**
    * Pass the set of attributes to customize the template. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. It's considered only if template is in New Template Language format.
    */
    'params'?: { [key: string]: any; };
    /**
    * List of email addresses and names (optional) of the recipients in bcc
    */
    'bcc'?: Array<SendSmtpEmailBcc>;
    /**
    * List of email addresses and names (optional) of the recipients in cc
    */
    'cc'?: Array<SendSmtpEmailCc>;
    'replyTo'?: SendSmtpEmailReplyTo1;
    /**
    * Custom subject specific to message version 
    */
    'subject'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<SendSmtpEmailTo1>"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "bcc",
            "baseName": "bcc",
            "type": "Array<SendSmtpEmailBcc>"
        },
        {
            "name": "cc",
            "baseName": "cc",
            "type": "Array<SendSmtpEmailCc>"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "SendSmtpEmailReplyTo1"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailMessageVersions.attributeTypeMap;
    }
}

/**
* Email (required), along with name (optional), on which transactional mail recipients will be able to reply back. For example, {\"email\":\"ann6533@example.com\", \"name\":\"Ann\"}.
*/
export class SendSmtpEmailReplyTo {
    /**
    * Email address in reply to
    */
    'email': string;
    /**
    * Name in reply to. Maximum allowed characters are 70.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailReplyTo.attributeTypeMap;
    }
}

/**
* Email (required), along with name (optional), on which transactional mail recipients will be able to reply back. For example, {\"email\":\"ann6533@example.com\", \"name\":\"Ann\"}
*/
export class SendSmtpEmailReplyTo1 {
    /**
    * Email address in reply to
    */
    'email': string;
    /**
    * Name in reply to. Maximum allowed characters are 70.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailReplyTo1.attributeTypeMap;
    }
}

/**
* Mandatory if `templateId` is not passed. Pass `name` (optional) and `email` OR `id` of sender from which emails will be sent. `name` will be ignored if passed along with sender `id`. For example, {\"name\":\"Mary from MyShop\", \"email\":\"no-reply@myshop.com\"} or {\"id\":2}
*/
export class SendSmtpEmailSender {
    /**
    * Name of the sender from which the emails will be sent. Maximum allowed characters are 70. Applicable only when email is passed.
    */
    'name'?: string;
    /**
    * Email of the sender from which the emails will be sent. Mandatory if sender id is not passed.
    */
    'email'?: string;
    /**
    * Id of the sender from which the emails will be sent. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email). Mandatory if email is not passed.
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailSender.attributeTypeMap;
    }
}

export class SendSmtpEmailTo {
    /**
    * Email address of the recipient
    */
    'email': string;
    /**
    * Name of the recipient. Maximum allowed characters are 70.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailTo.attributeTypeMap;
    }
}

export class SendSmtpEmailTo1 {
    /**
    * Email address of the recipient
    */
    'email': string;
    /**
    * Name of the recipient. **Maximum allowed characters are 70**.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendSmtpEmailTo1.attributeTypeMap;
    }
}

export class SendTemplateEmail {
    /**
    * Message ID of the template Email sent
    */
    'messageId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "messageId",
            "baseName": "messageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendTemplateEmail.attributeTypeMap;
    }
}

export class SendTestEmail {
    /**
    * List of the email addresses of the recipients whom you wish to send the test mail. If left empty, the test mail will be sent to your entire test list.
    */
    'emailTo'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailTo",
            "baseName": "emailTo",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SendTestEmail.attributeTypeMap;
    }
}

export class SendTestSms {
    /**
    * Mobile number of the recipient with the country code. This number must belong to one of your contacts in SendinBlue account and must not be blacklisted
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendTestSms.attributeTypeMap;
    }
}

export class SendTransacSms {
    /**
    * Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**
    */
    'sender': string;
    /**
    * Mobile number to send SMS with the country code
    */
    'recipient': string;
    /**
    * Content of the message. If more than 160 characters long, will be sent as multiple text messages
    */
    'content': string;
    /**
    * Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.
    */
    'type'?: SendTransacSms.TypeEnum;
    /**
    * Tag of the message
    */
    'tag'?: string;
    /**
    * Webhook to call for each event triggered by the message (delivered etc.)
    */
    'webUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "recipient",
            "baseName": "recipient",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "SendTransacSms.TypeEnum"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "webUrl",
            "baseName": "webUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendTransacSms.attributeTypeMap;
    }
}

export namespace SendTransacSms {
    export enum TypeEnum {
        Transactional = <any> 'transactional',
        Marketing = <any> 'marketing'
    }
}
export class UpdateAttribute {
    /**
    * Value of the attribute to update. Use only if the attribute's category is 'calculated' or 'global'
    */
    'value'?: string;
    /**
    * List of the values and labels that the attribute can take. Use only if the attribute's category is \"category\". For example, [{\"value\":1, \"label\":\"male\"}, {\"value\":2, \"label\":\"female\"}]
    */
    'enumeration'?: Array<UpdateAttributeEnumeration>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "enumeration",
            "baseName": "enumeration",
            "type": "Array<UpdateAttributeEnumeration>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAttribute.attributeTypeMap;
    }
}

export class UpdateAttributeEnumeration {
    /**
    * Id of the value
    */
    'value': number;
    /**
    * Label of the value
    */
    'label': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAttributeEnumeration.attributeTypeMap;
    }
}

/**
* Status of the campaign
*/
export class UpdateCampaignStatus {
    /**
    * Note:- replicateTemplate status will be available only for template type campaigns.
    */
    'status'?: UpdateCampaignStatus.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "UpdateCampaignStatus.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCampaignStatus.attributeTypeMap;
    }
}

export namespace UpdateCampaignStatus {
    export enum StatusEnum {
        Suspended = <any> 'suspended',
        Archive = <any> 'archive',
        Darchive = <any> 'darchive',
        Sent = <any> 'sent',
        Queued = <any> 'queued',
        Replicate = <any> 'replicate',
        ReplicateTemplate = <any> 'replicateTemplate',
        Draft = <any> 'draft'
    }
}
export class UpdateChild {
    /**
    * New Email address to update the child account
    */
    'email'?: string;
    /**
    * New First name to use to update the child account
    */
    'firstName'?: string;
    /**
    * New Last name to use to update the child account
    */
    'lastName'?: string;
    /**
    * New Company name to use to update the child account
    */
    'companyName'?: string;
    /**
    * New password for the child account to login
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChild.attributeTypeMap;
    }
}

export class UpdateChildAccountStatus {
    /**
    * Status of Transactional Email Platform activation for your account (true=enabled, false=disabled)
    */
    'transactionalEmail'?: boolean;
    /**
    * Status of Transactional SMS Platform activation for your account (true=enabled, false=disabled)
    */
    'transactionalSms'?: boolean;
    /**
    * Status of Marketing Automation Platform activation for your account (true=enabled, false=disabled)
    */
    'marketingAutomation'?: boolean;
    /**
    * Status of SMS Campaign Platform activation for your account (true=enabled, false=disabled)
    */
    'smsCampaign'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionalEmail",
            "baseName": "transactionalEmail",
            "type": "boolean"
        },
        {
            "name": "transactionalSms",
            "baseName": "transactionalSms",
            "type": "boolean"
        },
        {
            "name": "marketingAutomation",
            "baseName": "marketingAutomation",
            "type": "boolean"
        },
        {
            "name": "smsCampaign",
            "baseName": "smsCampaign",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChildAccountStatus.attributeTypeMap;
    }
}

export class UpdateChildDomain {
    /**
    * Value for the sender domain that will replace the existing domain
    */
    'domain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChildDomain.attributeTypeMap;
    }
}

export class UpdateContact {
    /**
    * Pass the set of attributes to be updated. These attributes must be present in your account. To update existing email address of a contact with the new one please pass EMAIL in attribtes. For example, `{ \"EMAIL\":\"newemail@domain.com\", \"FNAME\":\"Ellie\", \"LNAME\":\"Roger\"}`. Keep in mind transactional attributes can be updated the same way as normal attributes. Mobile Number in \"SMS\" field should be passed with proper country code. For example {\"SMS\":\"+91xxxxxxxxxx\"} or {\"SMS\":\"0091xxxxxxxxxx\"}
    */
    'attributes'?: any;
    /**
    * Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted = true)
    */
    'emailBlacklisted'?: boolean;
    /**
    * Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted = true)
    */
    'smsBlacklisted'?: boolean;
    /**
    * Ids of the lists to add the contact to
    */
    'listIds'?: Array<number>;
    /**
    * Ids of the lists to remove the contact from
    */
    'unlinkListIds'?: Array<number>;
    /**
    * transactional email forbidden sender for contact. Use only for email Contact
    */
    'smtpBlacklistSender'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "emailBlacklisted",
            "baseName": "emailBlacklisted",
            "type": "boolean"
        },
        {
            "name": "smsBlacklisted",
            "baseName": "smsBlacklisted",
            "type": "boolean"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        },
        {
            "name": "unlinkListIds",
            "baseName": "unlinkListIds",
            "type": "Array<number>"
        },
        {
            "name": "smtpBlacklistSender",
            "baseName": "smtpBlacklistSender",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateContact.attributeTypeMap;
    }
}

export class UpdateEmailCampaign {
    /**
    * Tag of the campaign
    */
    'tag'?: string;
    'sender'?: UpdateEmailCampaignSender;
    /**
    * Name of the campaign
    */
    'name'?: string;
    /**
    * Body of the message (HTML version). REQUIRED if htmlUrl is empty
    */
    'htmlContent'?: string;
    /**
    * Url which contents the body of the email message. REQUIRED if htmlContent is empty
    */
    'htmlUrl'?: string;
    /**
    * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
    */
    'scheduledAt'?: string;
    /**
    * Subject of the campaign
    */
    'subject'?: string;
    /**
    * Email on which campaign recipients will be able to reply to
    */
    'replyTo'?: string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField'?: string;
    'recipients'?: UpdateEmailCampaignRecipients;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl'?: string;
    /**
    * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email. You cannot send a campaign of more than 4MB with images embedded in the email. Campaigns with the images embedded in the email must be sent to less than 5000 contacts.
    */
    'inlineImageActivation'?: boolean;
    /**
    * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
    */
    'mirrorActive'?: boolean;
    /**
    * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
    */
    'recurring'?: boolean;
    /**
    * Footer of the email campaign
    */
    'footer'?: string;
    /**
    * Header of the email campaign
    */
    'header'?: string;
    /**
    * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
    */
    'utmCampaign'?: string;
    /**
    * Pass the set of attributes to customize the type 'classic' campaign. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. The 'params' field will get updated, only if the campaign is in New Template Language, else ignored. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
    */
    'params'?: any;
    /**
    * Set this to true if you want to send your campaign at best time. Note:- if true, warmup ip will be disabled.
    */
    'sendAtBestTime'?: boolean;
    /**
    * Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered if abTesting is set to true. 'subject' if passed is ignored.  Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
    */
    'abTesting'?: boolean;
    /**
    * Subject A of the campaign. Considered if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectA'?: string;
    /**
    * Subject B of the campaign. Considered if abTesting = true. subjectA & subjectB should have unique value
    */
    'subjectB'?: string;
    /**
    * Add the size of your test groups. Considered if abTesting = true. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
    */
    'splitRule'?: number;
    /**
    * Choose the metrics that will determinate the winning version. Considered if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed or alreday exist in record
    */
    'winnerCriteria'?: UpdateEmailCampaign.WinnerCriteriaEnum;
    /**
    * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Considered if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed or alreday exist in record
    */
    'winnerDelay'?: number;
    /**
    * Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
    */
    'ipWarmupEnable'?: boolean;
    /**
    * Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
    */
    'initialQuota'?: number;
    /**
    * Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
    */
    'increaseRate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "UpdateEmailCampaignSender"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "UpdateEmailCampaignRecipients"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "inlineImageActivation",
            "baseName": "inlineImageActivation",
            "type": "boolean"
        },
        {
            "name": "mirrorActive",
            "baseName": "mirrorActive",
            "type": "boolean"
        },
        {
            "name": "recurring",
            "baseName": "recurring",
            "type": "boolean"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "utmCampaign",
            "baseName": "utmCampaign",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "any"
        },
        {
            "name": "sendAtBestTime",
            "baseName": "sendAtBestTime",
            "type": "boolean"
        },
        {
            "name": "abTesting",
            "baseName": "abTesting",
            "type": "boolean"
        },
        {
            "name": "subjectA",
            "baseName": "subjectA",
            "type": "string"
        },
        {
            "name": "subjectB",
            "baseName": "subjectB",
            "type": "string"
        },
        {
            "name": "splitRule",
            "baseName": "splitRule",
            "type": "number"
        },
        {
            "name": "winnerCriteria",
            "baseName": "winnerCriteria",
            "type": "UpdateEmailCampaign.WinnerCriteriaEnum"
        },
        {
            "name": "winnerDelay",
            "baseName": "winnerDelay",
            "type": "number"
        },
        {
            "name": "ipWarmupEnable",
            "baseName": "ipWarmupEnable",
            "type": "boolean"
        },
        {
            "name": "initialQuota",
            "baseName": "initialQuota",
            "type": "number"
        },
        {
            "name": "increaseRate",
            "baseName": "increaseRate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEmailCampaign.attributeTypeMap;
    }
}

export namespace UpdateEmailCampaign {
    export enum WinnerCriteriaEnum {
        Open = <any> 'open',
        Click = <any> 'click'
    }
}
/**
* List ids to include/exclude from campaign
*/
export class UpdateEmailCampaignRecipients {
    /**
    * List ids which have to be excluded from a campaign
    */
    'exclusionListIds'?: Array<number>;
    /**
    * Lists Ids to send the campaign to. REQUIRED if already not present in campaign and scheduledAt is not empty
    */
    'listIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exclusionListIds",
            "baseName": "exclusionListIds",
            "type": "Array<number>"
        },
        {
            "name": "listIds",
            "baseName": "listIds",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEmailCampaignRecipients.attributeTypeMap;
    }
}

/**
* Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
*/
export class UpdateEmailCampaignSender {
    /**
    * Sender Name from which the campaign emails are sent
    */
    'name'?: string;
    /**
    * Sender email from which the campaign emails are sent
    */
    'email'?: string;
    /**
    * Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEmailCampaignSender.attributeTypeMap;
    }
}

export class UpdateList {
    /**
    * Name of the list. Either of the two parameters (name, folderId) can be updated at a time.
    */
    'name'?: string;
    /**
    * Id of the folder in which the list is to be moved. Either of the two parameters (name, folderId) can be updated at a time.
    */
    'folderId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "folderId",
            "baseName": "folderId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateList.attributeTypeMap;
    }
}

export class UpdateSender {
    /**
    * From Name to update the sender
    */
    'name'?: string;
    /**
    * From Email to update the sender
    */
    'email'?: string;
    /**
    * Only in case of dedicated IP, IPs to associate to the sender. If passed, will replace all the existing IPs.
    */
    'ips'?: Array<CreateSenderIps>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "ips",
            "baseName": "ips",
            "type": "Array<CreateSenderIps>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSender.attributeTypeMap;
    }
}

export class UpdateSmsCampaign {
    /**
    * Name of the campaign
    */
    'name'?: string;
    /**
    * Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**
    */
    'sender'?: string;
    /**
    * Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
    */
    'content'?: string;
    'recipients'?: CreateSmsCampaignRecipients;
    /**
    * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
    */
    'scheduledAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "CreateSmsCampaignRecipients"
        },
        {
            "name": "scheduledAt",
            "baseName": "scheduledAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSmsCampaign.attributeTypeMap;
    }
}

export class UpdateSmtpTemplate {
    /**
    * Tag of the template
    */
    'tag'?: string;
    'sender'?: UpdateSmtpTemplateSender;
    /**
    * Name of the template
    */
    'templateName'?: string;
    /**
    * Required if htmlUrl is empty. Body of the message (HTML must have more than 10 characters)
    */
    'htmlContent'?: string;
    /**
    * Required if htmlContent is empty. URL to the body of the email (HTML)
    */
    'htmlUrl'?: string;
    /**
    * Subject of the email
    */
    'subject'?: string;
    /**
    * Email on which campaign recipients will be able to reply to
    */
    'replyTo'?: string;
    /**
    * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your SendinBlue account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
    */
    'toField'?: string;
    /**
    * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
    */
    'attachmentUrl'?: string;
    /**
    * Status of the template. isActive = false means template is inactive, isActive = true means template is active
    */
    'isActive'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "UpdateSmtpTemplateSender"
        },
        {
            "name": "templateName",
            "baseName": "templateName",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "htmlUrl",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "toField",
            "baseName": "toField",
            "type": "string"
        },
        {
            "name": "attachmentUrl",
            "baseName": "attachmentUrl",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSmtpTemplate.attributeTypeMap;
    }
}

/**
* Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
*/
export class UpdateSmtpTemplateSender {
    /**
    * Name of the sender
    */
    'name'?: string;
    /**
    * Email of the sender
    */
    'email'?: string;
    /**
    * Select the sender for the template on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSmtpTemplateSender.attributeTypeMap;
    }
}

export class UpdateWebhook {
    /**
    * URL of the webhook
    */
    'url'?: string;
    /**
    * Description of the webhook
    */
    'description'?: string;
    /**
    * Events triggering the webhook. Possible values for Transactional type webhook – `sent` OR `request`, `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`, `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and `unsubscribed` and possible values for Marketing type webhook – `spam`, `opened`, `click`, `hardBounce`, `softBounce`, `unsubscribed`, `listAddition` and `delivered`
    */
    'events'?: Array<UpdateWebhook.EventsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<UpdateWebhook.EventsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWebhook.attributeTypeMap;
    }
}

export namespace UpdateWebhook {
    export enum EventsEnum {
        HardBounce = <any> 'hardBounce',
        SoftBounce = <any> 'softBounce',
        Blocked = <any> 'blocked',
        Spam = <any> 'spam',
        Delivered = <any> 'delivered',
        Request = <any> 'request',
        Click = <any> 'click',
        Invalid = <any> 'invalid',
        Deferred = <any> 'deferred',
        Opened = <any> 'opened',
        UniqueOpened = <any> 'uniqueOpened',
        Unsubscribed = <any> 'unsubscribed',
        ListAddition = <any> 'listAddition',
        ContactUpdated = <any> 'contactUpdated',
        ContactDeleted = <any> 'contactDeleted'
    }
}
export class UploadImageToGallery {
    /**
    * The absolute url of the image (no local file). Maximum allowed size for image is 2MB. Allowed extensions for images are - jpeg, jpg, png, bmp, gif.
    */
    'imageUrl': string;
    /**
    * Name of the image.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UploadImageToGallery.attributeTypeMap;
    }
}


const enumsMap: {[index: string]: any} = {
        "AbTestCampaignResult.WinningVersionEnum": AbTestCampaignResult.WinningVersionEnum,
        "AbTestCampaignResult.WinningCriteriaEnum": AbTestCampaignResult.WinningCriteriaEnum,
        "CreateAttribute.TypeEnum": CreateAttribute.TypeEnum,
        "CreateChild.LanguageEnum": CreateChild.LanguageEnum,
        "CreateEmailCampaign.WinnerCriteriaEnum": CreateEmailCampaign.WinnerCriteriaEnum,
        "CreateWebhook.EventsEnum": CreateWebhook.EventsEnum,
        "CreateWebhook.TypeEnum": CreateWebhook.TypeEnum,
        "EmailExportRecipients.RecipientsTypeEnum": EmailExportRecipients.RecipientsTypeEnum,
        "ErrorModel.CodeEnum": ErrorModel.CodeEnum,
        "GetAccountPlan.TypeEnum": GetAccountPlan.TypeEnum,
        "GetAccountPlan.CreditsTypeEnum": GetAccountPlan.CreditsTypeEnum,
        "GetAttributesAttributes.CategoryEnum": GetAttributesAttributes.CategoryEnum,
        "GetAttributesAttributes.TypeEnum": GetAttributesAttributes.TypeEnum,
        "GetCampaignOverview.TypeEnum": GetCampaignOverview.TypeEnum,
        "GetCampaignOverview.StatusEnum": GetCampaignOverview.StatusEnum,
        "GetEmailEventReportEvents.EventEnum": GetEmailEventReportEvents.EventEnum,
        "GetProcess.StatusEnum": GetProcess.StatusEnum,
        "GetSmsCampaignOverview.StatusEnum": GetSmsCampaignOverview.StatusEnum,
        "GetSmsEventReportEvents.EventEnum": GetSmsEventReportEvents.EventEnum,
        "GetTransacBlockedContactsReason.CodeEnum": GetTransacBlockedContactsReason.CodeEnum,
        "GetWebhook.TypeEnum": GetWebhook.TypeEnum,
        "RequestContactExportCustomContactFilter.ActionForContactsEnum": RequestContactExportCustomContactFilter.ActionForContactsEnum,
        "RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum": RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum,
        "RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum": RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum,
        "RequestSmsRecipientExport.RecipientsTypeEnum": RequestSmsRecipientExport.RecipientsTypeEnum,
        "SendReport.LanguageEnum": SendReport.LanguageEnum,
        "SendTransacSms.TypeEnum": SendTransacSms.TypeEnum,
        "UpdateCampaignStatus.StatusEnum": UpdateCampaignStatus.StatusEnum,
        "UpdateEmailCampaign.WinnerCriteriaEnum": UpdateEmailCampaign.WinnerCriteriaEnum,
        "UpdateWebhook.EventsEnum": UpdateWebhook.EventsEnum,
}

const typeMap: {[index: string]: any} = {
    "AbTestCampaignResult": AbTestCampaignResult,
    "AbTestCampaignResultClickedLinks": AbTestCampaignResultClickedLinks,
    "AbTestCampaignResultStatistics": AbTestCampaignResultStatistics,
    "AbTestVersionClicks": AbTestVersionClicks,
    "AbTestVersionClicksInner": AbTestVersionClicksInner,
    "AbTestVersionStats": AbTestVersionStats,
    "AddChildDomain": AddChildDomain,
    "AddContactToList": AddContactToList,
    "AddCredits": AddCredits,
    "BlockDomain": BlockDomain,
    "CreateAttribute": CreateAttribute,
    "CreateAttributeEnumeration": CreateAttributeEnumeration,
    "CreateChild": CreateChild,
    "CreateContact": CreateContact,
    "CreateDoiContact": CreateDoiContact,
    "CreateEmailCampaign": CreateEmailCampaign,
    "CreateEmailCampaignRecipients": CreateEmailCampaignRecipients,
    "CreateEmailCampaignSender": CreateEmailCampaignSender,
    "CreateList": CreateList,
    "CreateModel": CreateModel,
    "CreateReseller": CreateReseller,
    "CreateSender": CreateSender,
    "CreateSenderIps": CreateSenderIps,
    "CreateSenderModel": CreateSenderModel,
    "CreateSmsCampaign": CreateSmsCampaign,
    "CreateSmsCampaignRecipients": CreateSmsCampaignRecipients,
    "CreateSmtpEmail": CreateSmtpEmail,
    "CreateSmtpTemplate": CreateSmtpTemplate,
    "CreateSmtpTemplateSender": CreateSmtpTemplateSender,
    "CreateUpdateContactModel": CreateUpdateContactModel,
    "CreateUpdateFolder": CreateUpdateFolder,
    "CreateWebhook": CreateWebhook,
    "CreatedProcessId": CreatedProcessId,
    "DeleteHardbounces": DeleteHardbounces,
    "EmailExportRecipients": EmailExportRecipients,
    "ErrorModel": ErrorModel,
    "GetAccount": GetAccount,
    "GetAccountMarketingAutomation": GetAccountMarketingAutomation,
    "GetAccountPlan": GetAccountPlan,
    "GetAccountRelay": GetAccountRelay,
    "GetAccountRelayData": GetAccountRelayData,
    "GetAggregatedReport": GetAggregatedReport,
    "GetAttributes": GetAttributes,
    "GetAttributesAttributes": GetAttributesAttributes,
    "GetAttributesEnumeration": GetAttributesEnumeration,
    "GetBlockedDomains": GetBlockedDomains,
    "GetCampaignOverview": GetCampaignOverview,
    "GetCampaignRecipients": GetCampaignRecipients,
    "GetCampaignStats": GetCampaignStats,
    "GetChildAccountCreationStatus": GetChildAccountCreationStatus,
    "GetChildDomain": GetChildDomain,
    "GetChildDomains": GetChildDomains,
    "GetChildInfo": GetChildInfo,
    "GetChildInfoApiKeys": GetChildInfoApiKeys,
    "GetChildInfoApiKeysV2": GetChildInfoApiKeysV2,
    "GetChildInfoApiKeysV3": GetChildInfoApiKeysV3,
    "GetChildInfoCredits": GetChildInfoCredits,
    "GetChildInfoStatistics": GetChildInfoStatistics,
    "GetChildrenList": GetChildrenList,
    "GetClient": GetClient,
    "GetContactCampaignStats": GetContactCampaignStats,
    "GetContactCampaignStatsClicked": GetContactCampaignStatsClicked,
    "GetContactCampaignStatsOpened": GetContactCampaignStatsOpened,
    "GetContactCampaignStatsTransacAttributes": GetContactCampaignStatsTransacAttributes,
    "GetContactCampaignStatsUnsubscriptions": GetContactCampaignStatsUnsubscriptions,
    "GetContactDetails": GetContactDetails,
    "GetContacts": GetContacts,
    "GetDeviceBrowserStats": GetDeviceBrowserStats,
    "GetEmailCampaign": GetEmailCampaign,
    "GetEmailCampaigns": GetEmailCampaigns,
    "GetEmailEventReport": GetEmailEventReport,
    "GetEmailEventReportEvents": GetEmailEventReportEvents,
    "GetExtendedCampaignOverview": GetExtendedCampaignOverview,
    "GetExtendedCampaignOverviewSender": GetExtendedCampaignOverviewSender,
    "GetExtendedCampaignStats": GetExtendedCampaignStats,
    "GetExtendedCampaignStatsGlobalStats": GetExtendedCampaignStatsGlobalStats,
    "GetExtendedClient": GetExtendedClient,
    "GetExtendedClientAddress": GetExtendedClientAddress,
    "GetExtendedContactDetails": GetExtendedContactDetails,
    "GetExtendedContactDetailsStatistics": GetExtendedContactDetailsStatistics,
    "GetExtendedContactDetailsStatisticsClicked": GetExtendedContactDetailsStatisticsClicked,
    "GetExtendedContactDetailsStatisticsLinks": GetExtendedContactDetailsStatisticsLinks,
    "GetExtendedContactDetailsStatisticsMessagesSent": GetExtendedContactDetailsStatisticsMessagesSent,
    "GetExtendedContactDetailsStatisticsOpened": GetExtendedContactDetailsStatisticsOpened,
    "GetExtendedContactDetailsStatisticsUnsubscriptions": GetExtendedContactDetailsStatisticsUnsubscriptions,
    "GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription": GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription,
    "GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription": GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription,
    "GetExtendedList": GetExtendedList,
    "GetExtendedListCampaignStats": GetExtendedListCampaignStats,
    "GetFolder": GetFolder,
    "GetFolderLists": GetFolderLists,
    "GetFolders": GetFolders,
    "GetIp": GetIp,
    "GetIpFromSender": GetIpFromSender,
    "GetIps": GetIps,
    "GetIpsFromSender": GetIpsFromSender,
    "GetList": GetList,
    "GetLists": GetLists,
    "GetProcess": GetProcess,
    "GetProcesses": GetProcesses,
    "GetReports": GetReports,
    "GetReportsReports": GetReportsReports,
    "GetSendersList": GetSendersList,
    "GetSendersListIps": GetSendersListIps,
    "GetSendersListSenders": GetSendersListSenders,
    "GetSharedTemplateUrl": GetSharedTemplateUrl,
    "GetSmsCampaign": GetSmsCampaign,
    "GetSmsCampaignOverview": GetSmsCampaignOverview,
    "GetSmsCampaignRecipients": GetSmsCampaignRecipients,
    "GetSmsCampaignStats": GetSmsCampaignStats,
    "GetSmsCampaigns": GetSmsCampaigns,
    "GetSmsEventReport": GetSmsEventReport,
    "GetSmsEventReportEvents": GetSmsEventReportEvents,
    "GetSmtpTemplateOverview": GetSmtpTemplateOverview,
    "GetSmtpTemplateOverviewSender": GetSmtpTemplateOverviewSender,
    "GetSmtpTemplates": GetSmtpTemplates,
    "GetSsoToken": GetSsoToken,
    "GetStatsByBrowser": GetStatsByBrowser,
    "GetStatsByDevice": GetStatsByDevice,
    "GetStatsByDomain": GetStatsByDomain,
    "GetTransacAggregatedSmsReport": GetTransacAggregatedSmsReport,
    "GetTransacBlockedContacts": GetTransacBlockedContacts,
    "GetTransacBlockedContactsContacts": GetTransacBlockedContactsContacts,
    "GetTransacBlockedContactsReason": GetTransacBlockedContactsReason,
    "GetTransacEmailContent": GetTransacEmailContent,
    "GetTransacEmailContentEvents": GetTransacEmailContentEvents,
    "GetTransacEmailsList": GetTransacEmailsList,
    "GetTransacEmailsListTransactionalEmails": GetTransacEmailsListTransactionalEmails,
    "GetTransacSmsReport": GetTransacSmsReport,
    "GetTransacSmsReportReports": GetTransacSmsReportReports,
    "GetWebhook": GetWebhook,
    "GetWebhooks": GetWebhooks,
    "ManageIp": ManageIp,
    "PostContactInfo": PostContactInfo,
    "PostContactInfoContacts": PostContactInfoContacts,
    "PostSendFailed": PostSendFailed,
    "PostSendSmsTestFailed": PostSendSmsTestFailed,
    "RemainingCreditModel": RemainingCreditModel,
    "RemainingCreditModelChild": RemainingCreditModelChild,
    "RemainingCreditModelReseller": RemainingCreditModelReseller,
    "RemoveContactFromList": RemoveContactFromList,
    "RemoveCredits": RemoveCredits,
    "RequestContactExport": RequestContactExport,
    "RequestContactExportCustomContactFilter": RequestContactExportCustomContactFilter,
    "RequestContactImport": RequestContactImport,
    "RequestContactImportNewList": RequestContactImportNewList,
    "RequestSmsRecipientExport": RequestSmsRecipientExport,
    "SendEmail": SendEmail,
    "SendEmailAttachment": SendEmailAttachment,
    "SendReport": SendReport,
    "SendReportEmail": SendReportEmail,
    "SendSms": SendSms,
    "SendSmtpEmail": SendSmtpEmail,
    "SendSmtpEmailAttachment": SendSmtpEmailAttachment,
    "SendSmtpEmailBcc": SendSmtpEmailBcc,
    "SendSmtpEmailCc": SendSmtpEmailCc,
    "SendSmtpEmailMessageVersions": SendSmtpEmailMessageVersions,
    "SendSmtpEmailReplyTo": SendSmtpEmailReplyTo,
    "SendSmtpEmailReplyTo1": SendSmtpEmailReplyTo1,
    "SendSmtpEmailSender": SendSmtpEmailSender,
    "SendSmtpEmailTo": SendSmtpEmailTo,
    "SendSmtpEmailTo1": SendSmtpEmailTo1,
    "SendTemplateEmail": SendTemplateEmail,
    "SendTestEmail": SendTestEmail,
    "SendTestSms": SendTestSms,
    "SendTransacSms": SendTransacSms,
    "UpdateAttribute": UpdateAttribute,
    "UpdateAttributeEnumeration": UpdateAttributeEnumeration,
    "UpdateCampaignStatus": UpdateCampaignStatus,
    "UpdateChild": UpdateChild,
    "UpdateChildAccountStatus": UpdateChildAccountStatus,
    "UpdateChildDomain": UpdateChildDomain,
    "UpdateContact": UpdateContact,
    "UpdateEmailCampaign": UpdateEmailCampaign,
    "UpdateEmailCampaignRecipients": UpdateEmailCampaignRecipients,
    "UpdateEmailCampaignSender": UpdateEmailCampaignSender,
    "UpdateList": UpdateList,
    "UpdateSender": UpdateSender,
    "UpdateSmsCampaign": UpdateSmsCampaign,
    "UpdateSmtpTemplate": UpdateSmtpTemplate,
    "UpdateSmtpTemplateSender": UpdateSmtpTemplateSender,
    "UpdateWebhook": UpdateWebhook,
    "UploadImageToGallery": UploadImageToGallery,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username = '';
    public password = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username = '';
    public password = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountApiApiKeys {
    apiKey,
    partnerKey,
}

export class AccountApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountApiApiKeys, value: string) {
        (this.authentications as any)[AccountApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get your account information, plan and credits details
     * @param {*} [options] Override http request options.
     */
    public getAccount (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetAccount;  }> {
        const localVarPath = this.basePath + '/account';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttributesApiApiKeys {
    apiKey,
    partnerKey,
}

export class AttributesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AttributesApiApiKeys, value: string) {
        (this.authentications as any)[AttributesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the attribute
     * @param createAttribute Values to create an attribute
     * @param {*} [options] Override http request options.
     */
    public createAttribute (attributeCategory: 'normal' | 'transactional' | 'category' | 'calculated' | 'global', attributeName: string, createAttribute: CreateAttribute, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'createAttribute' is not null or undefined
        if (createAttribute === null || createAttribute === undefined) {
            throw new Error('Required parameter createAttribute was null or undefined when calling createAttribute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAttribute, "CreateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     * @param {*} [options] Override http request options.
     */
    public deleteAttribute (attributeCategory: 'normal' | 'transactional' | 'category' | 'calculated' | 'global', attributeName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling deleteAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling deleteAttribute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all attributes
     * @param {*} [options] Override http request options.
     */
    public getAttributes (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetAttributes;  }> {
        const localVarPath = this.basePath + '/contacts/attributes';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetAttributes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAttributes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     * @param updateAttribute Values to update an attribute
     * @param {*} [options] Override http request options.
     */
    public updateAttribute (attributeCategory: 'category' | 'calculated' | 'global', attributeName: string, updateAttribute: UpdateAttribute, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'updateAttribute' is not null or undefined
        if (updateAttribute === null || updateAttribute === undefined) {
            throw new Error('Required parameter updateAttribute was null or undefined when calling updateAttribute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAttribute, "UpdateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContactsApiApiKeys {
    apiKey,
    partnerKey,
}

export class ContactsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContactsApiApiKeys, value: string) {
        (this.authentications as any)[ContactsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add existing contacts to a list
     * @param listId Id of the list
     * @param contactEmails Emails addresses OR IDs of the contacts
     * @param {*} [options] Override http request options.
     */
    public addContactToList (listId: number, contactEmails: AddContactToList, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/add'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling addContactToList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling addContactToList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "AddContactToList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the attribute
     * @param createAttribute Values to create an attribute
     * @param {*} [options] Override http request options.
     */
    public createAttribute (attributeCategory: 'normal' | 'transactional' | 'category' | 'calculated' | 'global', attributeName: string, createAttribute: CreateAttribute, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling createAttribute.');
        }

        // verify required parameter 'createAttribute' is not null or undefined
        if (createAttribute === null || createAttribute === undefined) {
            throw new Error('Required parameter createAttribute was null or undefined when calling createAttribute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAttribute, "CreateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a contact
     * @param createContact Values to create a contact
     * @param {*} [options] Override http request options.
     */
    public createContact (createContact: CreateContact, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateUpdateContactModel;  }> {
        const localVarPath = this.basePath + '/contacts';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createContact' is not null or undefined
        if (createContact === null || createContact === undefined) {
            throw new Error('Required parameter createContact was null or undefined when calling createContact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createContact, "CreateContact")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateUpdateContactModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateUpdateContactModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create Contact via DOI (Double-Opt-In) Flow
     * @param createDoiContact Values to create the Double opt-in (DOI) contact
     * @param {*} [options] Override http request options.
     */
    public createDoiContact (createDoiContact: CreateDoiContact, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/doubleOptinConfirmation';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createDoiContact' is not null or undefined
        if (createDoiContact === null || createDoiContact === undefined) {
            throw new Error('Required parameter createDoiContact was null or undefined when calling createDoiContact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createDoiContact, "CreateDoiContact")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a folder
     * @param createFolder Name of the folder
     * @param {*} [options] Override http request options.
     */
    public createFolder (createFolder: CreateUpdateFolder, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createFolder' is not null or undefined
        if (createFolder === null || createFolder === undefined) {
            throw new Error('Required parameter createFolder was null or undefined when calling createFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a list
     * @param createList Values to create a list
     * @param {*} [options] Override http request options.
     */
    public createList (createList: CreateList, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createList' is not null or undefined
        if (createList === null || createList === undefined) {
            throw new Error('Required parameter createList was null or undefined when calling createList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createList, "CreateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     * @param {*} [options] Override http request options.
     */
    public deleteAttribute (attributeCategory: 'normal' | 'transactional' | 'category' | 'calculated' | 'global', attributeName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling deleteAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling deleteAttribute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a contact
     * @param identifier Email (urlencoded) OR ID of the contact
     * @param {*} [options] Override http request options.
     */
    public deleteContact (identifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/{identifier}'
            .replace('{' + 'identifier' + '}', encodeURIComponent(String(identifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'identifier' is not null or undefined
        if (identifier === null || identifier === undefined) {
            throw new Error('Required parameter identifier was null or undefined when calling deleteContact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a folder (and all its lists)
     * @param folderId Id of the folder
     * @param {*} [options] Override http request options.
     */
    public deleteFolder (folderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling deleteFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a list
     * @param listId Id of the list
     * @param {*} [options] Override http request options.
     */
    public deleteList (listId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling deleteList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all attributes
     * @param {*} [options] Override http request options.
     */
    public getAttributes (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetAttributes;  }> {
        const localVarPath = this.basePath + '/contacts/attributes';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetAttributes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAttributes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a contact's details
     * @param identifier Email (urlencoded) OR ID of the contact OR its SMS attribute value
     * @param {*} [options] Override http request options.
     */
    public getContactInfo (identifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetExtendedContactDetails;  }> {
        const localVarPath = this.basePath + '/contacts/{identifier}'
            .replace('{' + 'identifier' + '}', encodeURIComponent(String(identifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'identifier' is not null or undefined
        if (identifier === null || identifier === undefined) {
            throw new Error('Required parameter identifier was null or undefined when calling getContactInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetExtendedContactDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetExtendedContactDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email campaigns' statistics for a contact
     * @param identifier Email (urlencoded) OR ID of the contact
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate
     * @param {*} [options] Override http request options.
     */
    public getContactStats (identifier: string, startDate?: string, endDate?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetContactCampaignStats;  }> {
        const localVarPath = this.basePath + '/contacts/{identifier}/campaignStats'
            .replace('{' + 'identifier' + '}', encodeURIComponent(String(identifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'identifier' is not null or undefined
        if (identifier === null || identifier === undefined) {
            throw new Error('Required parameter identifier was null or undefined when calling getContactStats.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetContactCampaignStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContactCampaignStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the contacts
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getContacts (limit?: number, offset?: number, modifiedSince?: string, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetContacts;  }> {
        const localVarPath = this.basePath + '/contacts';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (modifiedSince !== undefined) {
            localVarQueryParameters['modifiedSince'] = ObjectSerializer.serialize(modifiedSince, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get contacts in a list
     * @param listId Id of the list
     * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getContactsFromList (listId: number, modifiedSince?: string, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetContacts;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getContactsFromList.');
        }

        if (modifiedSince !== undefined) {
            localVarQueryParameters['modifiedSince'] = ObjectSerializer.serialize(modifiedSince, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a folder's details
     * @param folderId id of the folder
     * @param {*} [options] Override http request options.
     */
    public getFolder (folderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolder;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get lists in a folder
     * @param folderId Id of the folder
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getFolderLists (folderId: number, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolderLists;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}/lists'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolderLists.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolderLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolderLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all folders
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getFolders (limit: number, offset: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolders;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getFolders.');
        }

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getFolders.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolders;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolders");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list's details
     * @param listId Id of the list
     * @param {*} [options] Override http request options.
     */
    public getList (listId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetExtendedList;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetExtendedList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetExtendedList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the lists
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getLists (limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetLists;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns the background process ID which on completion calls the notify URL that you have set in the input.
     * @summary Import contacts
     * @param requestContactImport Values to import contacts in Sendinblue. To know more about the expected format, please have a look at &#x60;&#x60;https://help.sendinblue.com/hc/en-us/articles/209499265-Build-contacts-lists-for-your-email-marketing-campaigns&#x60;&#x60;
     * @param {*} [options] Override http request options.
     */
    public importContacts (requestContactImport: RequestContactImport, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/contacts/import';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'requestContactImport' is not null or undefined
        if (requestContactImport === null || requestContactImport === undefined) {
            throw new Error('Required parameter requestContactImport was null or undefined when calling importContacts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestContactImport, "RequestContactImport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a contact from a list
     * @param listId Id of the list
     * @param contactEmails Emails addresses OR IDs of the contacts
     * @param {*} [options] Override http request options.
     */
    public removeContactFromList (listId: number, contactEmails: RemoveContactFromList, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/remove'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling removeContactFromList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling removeContactFromList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "RemoveContactFromList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns the background process ID which on completion calls the notify URL that you have set in the input. File will be available in csv.
     * @summary Export contacts
     * @param requestContactExport Values to request a contact export
     * @param {*} [options] Override http request options.
     */
    public requestContactExport (requestContactExport: RequestContactExport, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/contacts/export';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'requestContactExport' is not null or undefined
        if (requestContactExport === null || requestContactExport === undefined) {
            throw new Error('Required parameter requestContactExport was null or undefined when calling requestContactExport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestContactExport, "RequestContactExport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update contact attribute
     * @param attributeCategory Category of the attribute
     * @param attributeName Name of the existing attribute
     * @param updateAttribute Values to update an attribute
     * @param {*} [options] Override http request options.
     */
    public updateAttribute (attributeCategory: 'category' | 'calculated' | 'global', attributeName: string, updateAttribute: UpdateAttribute, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/attributes/{attributeCategory}/{attributeName}'
            .replace('{' + 'attributeCategory' + '}', encodeURIComponent(String(attributeCategory)))
            .replace('{' + 'attributeName' + '}', encodeURIComponent(String(attributeName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'attributeName' is not null or undefined
        if (attributeName === null || attributeName === undefined) {
            throw new Error('Required parameter attributeName was null or undefined when calling updateAttribute.');
        }

        // verify required parameter 'updateAttribute' is not null or undefined
        if (updateAttribute === null || updateAttribute === undefined) {
            throw new Error('Required parameter updateAttribute was null or undefined when calling updateAttribute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateAttribute, "UpdateAttribute")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a contact
     * @param identifier Email (urlencoded) OR ID of the contact
     * @param updateContact Values to update a contact
     * @param {*} [options] Override http request options.
     */
    public updateContact (identifier: string, updateContact: UpdateContact, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/{identifier}'
            .replace('{' + 'identifier' + '}', encodeURIComponent(String(identifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'identifier' is not null or undefined
        if (identifier === null || identifier === undefined) {
            throw new Error('Required parameter identifier was null or undefined when calling updateContact.');
        }

        // verify required parameter 'updateContact' is not null or undefined
        if (updateContact === null || updateContact === undefined) {
            throw new Error('Required parameter updateContact was null or undefined when calling updateContact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateContact, "UpdateContact")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a folder
     * @param folderId Id of the folder
     * @param updateFolder Name of the folder
     * @param {*} [options] Override http request options.
     */
    public updateFolder (folderId: number, updateFolder: CreateUpdateFolder, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling updateFolder.');
        }

        // verify required parameter 'updateFolder' is not null or undefined
        if (updateFolder === null || updateFolder === undefined) {
            throw new Error('Required parameter updateFolder was null or undefined when calling updateFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a list
     * @param listId Id of the list
     * @param updateList Values to update a list
     * @param {*} [options] Override http request options.
     */
    public updateList (listId: number, updateList: UpdateList, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling updateList.');
        }

        // verify required parameter 'updateList' is not null or undefined
        if (updateList === null || updateList === undefined) {
            throw new Error('Required parameter updateList was null or undefined when calling updateList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateList, "UpdateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EmailCampaignsApiApiKeys {
    apiKey,
    partnerKey,
}

export class EmailCampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EmailCampaignsApiApiKeys, value: string) {
        (this.authentications as any)[EmailCampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create an email campaign
     * @param emailCampaigns Values to create a campaign
     * @param {*} [options] Override http request options.
     */
    public createEmailCampaign (emailCampaigns: CreateEmailCampaign, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/emailCampaigns';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'emailCampaigns' is not null or undefined
        if (emailCampaigns === null || emailCampaigns === undefined) {
            throw new Error('Required parameter emailCampaigns was null or undefined when calling createEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaigns, "CreateEmailCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an email campaign
     * @param campaignId id of the campaign
     * @param {*} [options] Override http request options.
     */
    public deleteEmailCampaign (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling deleteEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export the recipients of an email campaign
     * @param campaignId Id of the campaign
     * @param recipientExport Values to send for a recipient export request
     * @param {*} [options] Override http request options.
     */
    public emailExportRecipients (campaignId: number, recipientExport?: EmailExportRecipients, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/exportRecipients'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling emailExportRecipients.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(recipientExport, "EmailExportRecipients")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtain winning version of an A/B test email campaign
     * @summary Get an A/B test email campaign results
     * @param campaignId Id of the A/B test campaign
     * @param {*} [options] Override http request options.
     */
    public getAbTestCampaignResult (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AbTestCampaignResult;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/abTestCampaignResult'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getAbTestCampaignResult.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AbTestCampaignResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AbTestCampaignResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an email campaign report
     * @param campaignId Id of the campaign
     * @param {*} [options] Override http request options.
     */
    public getEmailCampaign (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetEmailCampaign;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetEmailCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmailCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all your created email campaigns
     * @param type Filter on the type of the campaigns
     * @param status Filter on the status of the campaign
     * @param startDate Mandatory if endDate is used. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param endDate Mandatory if startDate is used. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param limit Number of documents per page
     * @param offset Index of the first document in the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getEmailCampaigns (type?: 'classic' | 'trigger', status?: 'suspended' | 'archive' | 'sent' | 'queued' | 'draft' | 'inProcess', startDate?: string, endDate?: string, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetEmailCampaigns;  }> {
        const localVarPath = this.basePath + '/emailCampaigns';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'classic' | 'trigger'");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'suspended' | 'archive' | 'sent' | 'queued' | 'draft' | 'inProcess'");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetEmailCampaigns;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmailCampaigns");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a unique URL to share & import an email template from one Sendinblue account to another.
     * @summary Get a shared template url
     * @param campaignId Id of the campaign or template
     * @param {*} [options] Override http request options.
     */
    public getSharedTemplateUrl (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSharedTemplateUrl;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sharedUrl'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getSharedTemplateUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSharedTemplateUrl;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSharedTemplateUrl");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send an email campaign immediately, based on campaignId
     * @param campaignId Id of the campaign
     * @param {*} [options] Override http request options.
     */
    public sendEmailCampaignNow (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sendNow'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendEmailCampaignNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A PDF will be sent to the specified email addresses
     * @summary Send the report of a campaign
     * @param campaignId Id of the campaign
     * @param sendReport Values for send a report
     * @param {*} [options] Override http request options.
     */
    public sendReport (campaignId: number, sendReport: SendReport, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sendReport'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendReport.');
        }

        // verify required parameter 'sendReport' is not null or undefined
        if (sendReport === null || sendReport === undefined) {
            throw new Error('Required parameter sendReport was null or undefined when calling sendReport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendReport, "SendReport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send an email campaign to your test list
     * @param campaignId Id of the campaign
     * @param emailTo 
     * @param {*} [options] Override http request options.
     */
    public sendTestEmail (campaignId: number, emailTo: SendTestEmail, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/sendTest'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendTestEmail.');
        }

        // verify required parameter 'emailTo' is not null or undefined
        if (emailTo === null || emailTo === undefined) {
            throw new Error('Required parameter emailTo was null or undefined when calling sendTestEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailTo, "SendTestEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an email campaign status
     * @param campaignId Id of the campaign
     * @param status Status of the campaign
     * @param {*} [options] Override http request options.
     */
    public updateCampaignStatus (campaignId: number, status: UpdateCampaignStatus, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}/status'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateCampaignStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateCampaignStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "UpdateCampaignStatus")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an email campaign
     * @param campaignId Id of the campaign
     * @param emailCampaign Values to update a campaign
     * @param {*} [options] Override http request options.
     */
    public updateEmailCampaign (campaignId: number, emailCampaign: UpdateEmailCampaign, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateEmailCampaign.');
        }

        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling updateEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "UpdateEmailCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload an image to your account's image gallery
     * @param uploadImage Parameters to upload an image
     * @param {*} [options] Override http request options.
     */
    public uploadImageToGallery (uploadImage: UploadImageToGallery, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/emailCampaigns/images';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'uploadImage' is not null or undefined
        if (uploadImage === null || uploadImage === undefined) {
            throw new Error('Required parameter uploadImage was null or undefined when calling uploadImageToGallery.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uploadImage, "UploadImageToGallery")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FoldersApiApiKeys {
    apiKey,
    partnerKey,
}

export class FoldersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FoldersApiApiKeys, value: string) {
        (this.authentications as any)[FoldersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a folder
     * @param createFolder Name of the folder
     * @param {*} [options] Override http request options.
     */
    public createFolder (createFolder: CreateUpdateFolder, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createFolder' is not null or undefined
        if (createFolder === null || createFolder === undefined) {
            throw new Error('Required parameter createFolder was null or undefined when calling createFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a folder (and all its lists)
     * @param folderId Id of the folder
     * @param {*} [options] Override http request options.
     */
    public deleteFolder (folderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling deleteFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a folder's details
     * @param folderId id of the folder
     * @param {*} [options] Override http request options.
     */
    public getFolder (folderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolder;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get lists in a folder
     * @param folderId Id of the folder
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getFolderLists (folderId: number, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolderLists;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}/lists'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolderLists.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolderLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolderLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all folders
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getFolders (limit: number, offset: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolders;  }> {
        const localVarPath = this.basePath + '/contacts/folders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getFolders.');
        }

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getFolders.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolders;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolders");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a folder
     * @param folderId Id of the folder
     * @param updateFolder Name of the folder
     * @param {*} [options] Override http request options.
     */
    public updateFolder (folderId: number, updateFolder: CreateUpdateFolder, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling updateFolder.');
        }

        // verify required parameter 'updateFolder' is not null or undefined
        if (updateFolder === null || updateFolder === undefined) {
            throw new Error('Required parameter updateFolder was null or undefined when calling updateFolder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateFolder, "CreateUpdateFolder")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ListsApiApiKeys {
    apiKey,
    partnerKey,
}

export class ListsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ListsApiApiKeys, value: string) {
        (this.authentications as any)[ListsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add existing contacts to a list
     * @param listId Id of the list
     * @param contactEmails Emails addresses OR IDs of the contacts
     * @param {*} [options] Override http request options.
     */
    public addContactToList (listId: number, contactEmails: AddContactToList, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/add'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling addContactToList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling addContactToList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "AddContactToList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a list
     * @param createList Values to create a list
     * @param {*} [options] Override http request options.
     */
    public createList (createList: CreateList, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createList' is not null or undefined
        if (createList === null || createList === undefined) {
            throw new Error('Required parameter createList was null or undefined when calling createList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createList, "CreateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a list
     * @param listId Id of the list
     * @param {*} [options] Override http request options.
     */
    public deleteList (listId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling deleteList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get contacts in a list
     * @param listId Id of the list
     * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getContactsFromList (listId: number, modifiedSince?: string, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetContacts;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getContactsFromList.');
        }

        if (modifiedSince !== undefined) {
            localVarQueryParameters['modifiedSince'] = ObjectSerializer.serialize(modifiedSince, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get lists in a folder
     * @param folderId Id of the folder
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getFolderLists (folderId: number, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetFolderLists;  }> {
        const localVarPath = this.basePath + '/contacts/folders/{folderId}/lists'
            .replace('{' + 'folderId' + '}', encodeURIComponent(String(folderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'folderId' is not null or undefined
        if (folderId === null || folderId === undefined) {
            throw new Error('Required parameter folderId was null or undefined when calling getFolderLists.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetFolderLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetFolderLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list's details
     * @param listId Id of the list
     * @param {*} [options] Override http request options.
     */
    public getList (listId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetExtendedList;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetExtendedList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetExtendedList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the lists
     * @param limit Number of documents per page
     * @param offset Index of the first document of the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getLists (limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetLists;  }> {
        const localVarPath = this.basePath + '/contacts/lists';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetLists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetLists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a contact from a list
     * @param listId Id of the list
     * @param contactEmails Emails addresses OR IDs of the contacts
     * @param {*} [options] Override http request options.
     */
    public removeContactFromList (listId: number, contactEmails: RemoveContactFromList, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}/contacts/remove'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling removeContactFromList.');
        }

        // verify required parameter 'contactEmails' is not null or undefined
        if (contactEmails === null || contactEmails === undefined) {
            throw new Error('Required parameter contactEmails was null or undefined when calling removeContactFromList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactEmails, "RemoveContactFromList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PostContactInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostContactInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a list
     * @param listId Id of the list
     * @param updateList Values to update a list
     * @param {*} [options] Override http request options.
     */
    public updateList (listId: number, updateList: UpdateList, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/contacts/lists/{listId}'
            .replace('{' + 'listId' + '}', encodeURIComponent(String(listId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling updateList.');
        }

        // verify required parameter 'updateList' is not null or undefined
        if (updateList === null || updateList === undefined) {
            throw new Error('Required parameter updateList was null or undefined when calling updateList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateList, "UpdateList")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessApiApiKeys {
    apiKey,
    partnerKey,
}

export class ProcessApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessApiApiKeys, value: string) {
        (this.authentications as any)[ProcessApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Return the informations for a process
     * @param processId Id of the process
     * @param {*} [options] Override http request options.
     */
    public getProcess (processId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetProcess;  }> {
        const localVarPath = this.basePath + '/processes/{processId}'
            .replace('{' + 'processId' + '}', encodeURIComponent(String(processId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'processId' is not null or undefined
        if (processId === null || processId === undefined) {
            throw new Error('Required parameter processId was null or undefined when calling getProcess.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetProcess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetProcess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all the processes for your account
     * @param limit Number limitation for the result returned
     * @param offset Beginning point in the list to retrieve from.
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getProcesses (limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetProcesses;  }> {
        const localVarPath = this.basePath + '/processes';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetProcesses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetProcesses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ResellerApiApiKeys {
    apiKey,
    partnerKey,
}

export class ResellerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ResellerApiApiKeys, value: string) {
        (this.authentications as any)[ResellerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add Email and/or SMS credits to a specific child account
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param addCredits Values to post to add credit to a specific child account
     * @param {*} [options] Override http request options.
     */
    public addCredits (childIdentifier: string, addCredits: AddCredits, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RemainingCreditModel;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/credits/add'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling addCredits.');
        }

        // verify required parameter 'addCredits' is not null or undefined
        if (addCredits === null || addCredits === undefined) {
            throw new Error('Required parameter addCredits was null or undefined when calling addCredits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addCredits, "AddCredits")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RemainingCreditModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RemainingCreditModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Associate a dedicated IP to the child
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param ip IP to associate
     * @param {*} [options] Override http request options.
     */
    public associateIpToChild (childIdentifier: string, ip: ManageIp, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/ips/associate'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling associateIpToChild.');
        }

        // verify required parameter 'ip' is not null or undefined
        if (ip === null || ip === undefined) {
            throw new Error('Required parameter ip was null or undefined when calling associateIpToChild.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ip, "ManageIp")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a domain for a child account
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param addChildDomain Sender domain to add for a specific child account. This will not be displayed to the parent account.
     * @param {*} [options] Override http request options.
     */
    public createChildDomain (childIdentifier: string, addChildDomain: AddChildDomain, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/domains'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling createChildDomain.');
        }

        // verify required parameter 'addChildDomain' is not null or undefined
        if (addChildDomain === null || addChildDomain === undefined) {
            throw new Error('Required parameter addChildDomain was null or undefined when calling createChildDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addChildDomain, "AddChildDomain")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a reseller child
     * @param resellerChild reseller child to add
     * @param {*} [options] Override http request options.
     */
    public createResellerChild (resellerChild?: CreateChild, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateReseller;  }> {
        const localVarPath = this.basePath + '/reseller/children';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerChild, "CreateChild")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateReseller;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateReseller");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the sender domain of the reseller child based on the childIdentifier and domainName passed
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param domainName Pass the existing domain that needs to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteChildDomain (childIdentifier: string, domainName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/domains/{domainName}'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)))
            .replace('{' + 'domainName' + '}', encodeURIComponent(String(domainName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling deleteChildDomain.');
        }

        // verify required parameter 'domainName' is not null or undefined
        if (domainName === null || domainName === undefined) {
            throw new Error('Required parameter domainName was null or undefined when calling deleteChildDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a single reseller child based on the child identifier supplied
     * @param childIdentifier Either auth key or child id of reseller&#39;s child
     * @param {*} [options] Override http request options.
     */
    public deleteResellerChild (childIdentifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling deleteResellerChild.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Dissociate a dedicated IP to the child
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param ip IP to dissociate
     * @param {*} [options] Override http request options.
     */
    public dissociateIpFromChild (childIdentifier: string, ip: ManageIp, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/ips/dissociate'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling dissociateIpFromChild.');
        }

        // verify required parameter 'ip' is not null or undefined
        if (ip === null || ip === undefined) {
            throw new Error('Required parameter ip was null or undefined when calling dissociateIpFromChild.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ip, "ManageIp")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the status of a reseller's child account creation, whether it is successfully created (exists) or not based on the identifier supplied
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param {*} [options] Override http request options.
     */
    public getChildAccountCreationStatus (childIdentifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetChildAccountCreationStatus;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/accountCreationStatus'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling getChildAccountCreationStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetChildAccountCreationStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildAccountCreationStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all sender domains for a specific child account
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param {*} [options] Override http request options.
     */
    public getChildDomains (childIdentifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetChildDomains;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/domains'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling getChildDomains.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetChildDomains;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildDomains");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a child account's details
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param {*} [options] Override http request options.
     */
    public getChildInfo (childIdentifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetChildInfo;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling getChildInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetChildInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of all children accounts
     * @param limit Number of documents for child accounts information per page
     * @param offset Index of the first document in the page
     * @param {*} [options] Override http request options.
     */
    public getResellerChilds (limit?: number, offset?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetChildrenList;  }> {
        const localVarPath = this.basePath + '/reseller/children';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetChildrenList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetChildrenList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns a session [token] which will remain valid for a short period of time. A child account will be able to access a white-labeled section by using the following url pattern => https:/email.mydomain.com/login/sso?token=[token]
     * @summary Get session token to access Sendinblue (SSO)
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param {*} [options] Override http request options.
     */
    public getSsoToken (childIdentifier: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSsoToken;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/auth'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling getSsoToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSsoToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSsoToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove Email and/or SMS credits from a specific child account
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param removeCredits Values to post to remove email or SMS credits from a specific child account
     * @param {*} [options] Override http request options.
     */
    public removeCredits (childIdentifier: string, removeCredits: RemoveCredits, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RemainingCreditModel;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/credits/remove'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling removeCredits.');
        }

        // verify required parameter 'removeCredits' is not null or undefined
        if (removeCredits === null || removeCredits === undefined) {
            throw new Error('Required parameter removeCredits was null or undefined when calling removeCredits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(removeCredits, "RemoveCredits")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RemainingCreditModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RemainingCreditModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update info of reseller's child account status based on the childIdentifier supplied
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param updateChildAccountStatus values to update in child account status
     * @param {*} [options] Override http request options.
     */
    public updateChildAccountStatus (childIdentifier: string, updateChildAccountStatus: UpdateChildAccountStatus, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/accountStatus'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling updateChildAccountStatus.');
        }

        // verify required parameter 'updateChildAccountStatus' is not null or undefined
        if (updateChildAccountStatus === null || updateChildAccountStatus === undefined) {
            throw new Error('Required parameter updateChildAccountStatus was null or undefined when calling updateChildAccountStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateChildAccountStatus, "UpdateChildAccountStatus")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the sender domain of reseller's child based on the childIdentifier and domainName passed
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param domainName Pass the existing domain that needs to be updated
     * @param updateChildDomain value to update for sender domain
     * @param {*} [options] Override http request options.
     */
    public updateChildDomain (childIdentifier: string, domainName: string, updateChildDomain: UpdateChildDomain, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}/domains/{domainName}'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)))
            .replace('{' + 'domainName' + '}', encodeURIComponent(String(domainName)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling updateChildDomain.');
        }

        // verify required parameter 'domainName' is not null or undefined
        if (domainName === null || domainName === undefined) {
            throw new Error('Required parameter domainName was null or undefined when calling updateChildDomain.');
        }

        // verify required parameter 'updateChildDomain' is not null or undefined
        if (updateChildDomain === null || updateChildDomain === undefined) {
            throw new Error('Required parameter updateChildDomain was null or undefined when calling updateChildDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateChildDomain, "UpdateChildDomain")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update info of reseller's child based on the child identifier supplied
     * @param childIdentifier Either auth key or id of reseller&#39;s child
     * @param resellerChild values to update in child profile
     * @param {*} [options] Override http request options.
     */
    public updateResellerChild (childIdentifier: string, resellerChild: UpdateChild, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/reseller/children/{childIdentifier}'
            .replace('{' + 'childIdentifier' + '}', encodeURIComponent(String(childIdentifier)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'childIdentifier' is not null or undefined
        if (childIdentifier === null || childIdentifier === undefined) {
            throw new Error('Required parameter childIdentifier was null or undefined when calling updateResellerChild.');
        }

        // verify required parameter 'resellerChild' is not null or undefined
        if (resellerChild === null || resellerChild === undefined) {
            throw new Error('Required parameter resellerChild was null or undefined when calling updateResellerChild.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerChild, "UpdateChild")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SMSCampaignsApiApiKeys {
    apiKey,
    partnerKey,
}

export class SMSCampaignsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SMSCampaignsApiApiKeys, value: string) {
        (this.authentications as any)[SMSCampaignsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates an SMS campaign
     * @param createSmsCampaign Values to create an SMS Campaign
     * @param {*} [options] Override http request options.
     */
    public createSmsCampaign (createSmsCampaign: CreateSmsCampaign, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/smsCampaigns';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createSmsCampaign' is not null or undefined
        if (createSmsCampaign === null || createSmsCampaign === undefined) {
            throw new Error('Required parameter createSmsCampaign was null or undefined when calling createSmsCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSmsCampaign, "CreateSmsCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an SMS campaign
     * @param campaignId id of the SMS campaign
     * @param {*} [options] Override http request options.
     */
    public deleteSmsCampaign (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling deleteSmsCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an SMS campaign
     * @param campaignId id of the SMS campaign
     * @param {*} [options] Override http request options.
     */
    public getSmsCampaign (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSmsCampaign;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling getSmsCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSmsCampaign;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmsCampaign");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns the information for all your created SMS campaigns
     * @param status Status of campaign.
     * @param startDate Mandatory if endDate is used. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent sms campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param endDate Mandatory if startDate is used. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent sms campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
     * @param limit Number limitation for the result returned
     * @param offset Beginning point in the list to retrieve from.
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getSmsCampaigns (status?: 'suspended' | 'archive' | 'sent' | 'queued' | 'draft' | 'inProcess', startDate?: string, endDate?: string, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSmsCampaigns;  }> {
        const localVarPath = this.basePath + '/smsCampaigns';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'suspended' | 'archive' | 'sent' | 'queued' | 'draft' | 'inProcess'");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSmsCampaigns;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmsCampaigns");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * It returns the background process ID which on completion calls the notify URL that you have set in the input.
     * @summary Export an SMS campaign's recipients
     * @param campaignId id of the campaign
     * @param recipientExport Values to send for a recipient export request
     * @param {*} [options] Override http request options.
     */
    public requestSmsRecipientExport (campaignId: number, recipientExport?: RequestSmsRecipientExport, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/exportRecipients'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling requestSmsRecipientExport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(recipientExport, "RequestSmsRecipientExport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreatedProcessId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatedProcessId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send your SMS campaign immediately
     * @param campaignId id of the campaign
     * @param {*} [options] Override http request options.
     */
    public sendSmsCampaignNow (campaignId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/sendNow'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendSmsCampaignNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send report of Sent and Archived campaign, to the specified email addresses, with respective data and a pdf attachment in detail.
     * @summary Send an SMS campaign's report
     * @param campaignId id of the campaign
     * @param sendReport Values for send a report
     * @param {*} [options] Override http request options.
     */
    public sendSmsReport (campaignId: number, sendReport: SendReport, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/sendReport'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendSmsReport.');
        }

        // verify required parameter 'sendReport' is not null or undefined
        if (sendReport === null || sendReport === undefined) {
            throw new Error('Required parameter sendReport was null or undefined when calling sendSmsReport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendReport, "SendReport")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a test SMS campaign
     * @param campaignId Id of the SMS campaign
     * @param phoneNumber Mobile number of the recipient with the country code. This number must belong to one of your contacts in SendinBlue account and must not be blacklisted
     * @param {*} [options] Override http request options.
     */
    public sendTestSms (campaignId: number, phoneNumber: SendTestSms, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/sendTest'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling sendTestSms.');
        }

        // verify required parameter 'phoneNumber' is not null or undefined
        if (phoneNumber === null || phoneNumber === undefined) {
            throw new Error('Required parameter phoneNumber was null or undefined when calling sendTestSms.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(phoneNumber, "SendTestSms")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an SMS campaign
     * @param campaignId id of the SMS campaign
     * @param updateSmsCampaign Values to update an SMS Campaign
     * @param {*} [options] Override http request options.
     */
    public updateSmsCampaign (campaignId: number, updateSmsCampaign: UpdateSmsCampaign, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateSmsCampaign.');
        }

        // verify required parameter 'updateSmsCampaign' is not null or undefined
        if (updateSmsCampaign === null || updateSmsCampaign === undefined) {
            throw new Error('Required parameter updateSmsCampaign was null or undefined when calling updateSmsCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateSmsCampaign, "UpdateSmsCampaign")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a campaign's status
     * @param campaignId id of the campaign
     * @param status Status of the campaign.
     * @param {*} [options] Override http request options.
     */
    public updateSmsCampaignStatus (campaignId: number, status: UpdateCampaignStatus, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smsCampaigns/{campaignId}/status'
            .replace('{' + 'campaignId' + '}', encodeURIComponent(String(campaignId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateSmsCampaignStatus.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling updateSmsCampaignStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(status, "UpdateCampaignStatus")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SendersApiApiKeys {
    apiKey,
    partnerKey,
}

export class SendersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SendersApiApiKeys, value: string) {
        (this.authentications as any)[SendersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new sender
     * @param sender sender&#39;s name
     * @param {*} [options] Override http request options.
     */
    public createSender (sender?: CreateSender, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateSenderModel;  }> {
        const localVarPath = this.basePath + '/senders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sender, "CreateSender")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateSenderModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSenderModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a sender
     * @param senderId Id of the sender
     * @param {*} [options] Override http request options.
     */
    public deleteSender (senderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/senders/{senderId}'
            .replace('{' + 'senderId' + '}', encodeURIComponent(String(senderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'senderId' is not null or undefined
        if (senderId === null || senderId === undefined) {
            throw new Error('Required parameter senderId was null or undefined when calling deleteSender.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the dedicated IPs for your account
     * @param {*} [options] Override http request options.
     */
    public getIps (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetIps;  }> {
        const localVarPath = this.basePath + '/senders/ips';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetIps;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetIps");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the dedicated IPs for a sender
     * @param senderId Id of the sender
     * @param {*} [options] Override http request options.
     */
    public getIpsFromSender (senderId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetIpsFromSender;  }> {
        const localVarPath = this.basePath + '/senders/{senderId}/ips'
            .replace('{' + 'senderId' + '}', encodeURIComponent(String(senderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'senderId' is not null or undefined
        if (senderId === null || senderId === undefined) {
            throw new Error('Required parameter senderId was null or undefined when calling getIpsFromSender.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetIpsFromSender;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetIpsFromSender");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of all your senders
     * @param ip Filter your senders for a specific ip (available for dedicated IP usage only)
     * @param domain Filter your senders for a specific domain
     * @param {*} [options] Override http request options.
     */
    public getSenders (ip?: string, domain?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSendersList;  }> {
        const localVarPath = this.basePath + '/senders';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (ip !== undefined) {
            localVarQueryParameters['ip'] = ObjectSerializer.serialize(ip, "string");
        }

        if (domain !== undefined) {
            localVarQueryParameters['domain'] = ObjectSerializer.serialize(domain, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSendersList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSendersList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a sender
     * @param senderId Id of the sender
     * @param sender sender&#39;s name
     * @param {*} [options] Override http request options.
     */
    public updateSender (senderId: number, sender?: UpdateSender, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/senders/{senderId}'
            .replace('{' + 'senderId' + '}', encodeURIComponent(String(senderId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'senderId' is not null or undefined
        if (senderId === null || senderId === undefined) {
            throw new Error('Required parameter senderId was null or undefined when calling updateSender.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sender, "UpdateSender")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionalEmailsApiApiKeys {
    apiKey,
    partnerKey,
}

export class TransactionalEmailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionalEmailsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionalEmailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Blocks a new domain in order to avoid messages being sent to the same
     * @summary Add a new domain to the list of blocked domains
     * @param blockDomain 
     * @param {*} [options] Override http request options.
     */
    public blockNewDomain (blockDomain: BlockDomain, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/blockedDomains';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'blockDomain' is not null or undefined
        if (blockDomain === null || blockDomain === undefined) {
            throw new Error('Required parameter blockDomain was null or undefined when calling blockNewDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(blockDomain, "BlockDomain")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an email template
     * @param smtpTemplate values to update in transactional email template
     * @param {*} [options] Override http request options.
     */
    public createSmtpTemplate (smtpTemplate: CreateSmtpTemplate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/smtp/templates';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'smtpTemplate' is not null or undefined
        if (smtpTemplate === null || smtpTemplate === undefined) {
            throw new Error('Required parameter smtpTemplate was null or undefined when calling createSmtpTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smtpTemplate, "CreateSmtpTemplate")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unblocks an existing domain from the list of blocked domains
     * @summary Unblock an existing domain from the list of blocked domains
     * @param domain The name of the domain to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteBlockedDomain (domain: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/blockedDomains/{domain}'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteBlockedDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
     * @summary Delete hardbounces
     * @param deleteHardbounces values to delete hardbounces
     * @param {*} [options] Override http request options.
     */
    public deleteHardbounces (deleteHardbounces?: DeleteHardbounces, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/deleteHardbounces';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deleteHardbounces, "DeleteHardbounces")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an inactive email template
     * @param templateId id of the template
     * @param {*} [options] Override http request options.
     */
    public deleteSmtpTemplate (templateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling deleteSmtpTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your transactional email activity aggregated over a period of time
     * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
     * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param tag Tag of the emails
     * @param {*} [options] Override http request options.
     */
    public getAggregatedSmtpReport (startDate?: string, endDate?: string, days?: number, tag?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetAggregatedReport;  }> {
        const localVarPath = this.basePath + '/smtp/statistics/aggregatedReport';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetAggregatedReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAggregatedReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of blocked domains
     * @summary Get the list of blocked domains
     * @param {*} [options] Override http request options.
     */
    public getBlockedDomains (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetBlockedDomains;  }> {
        const localVarPath = this.basePath + '/smtp/blockedDomains';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetBlockedDomains;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetBlockedDomains");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all your transactional email activity (unaggregated events)
     * @param limit Number limitation for the result returned
     * @param offset Beginning point in the list to retrieve from.
     * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
     * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param email Filter the report for a specific email addresses
     * @param event Filter the report for a specific event type
     * @param tags Filter the report for tags (serialized and urlencoded array)
     * @param messageId Filter on a specific message id
     * @param templateId Filter on a specific template id
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getEmailEventReport (limit?: number, offset?: number, startDate?: string, endDate?: string, days?: number, email?: string, event?: 'bounces' | 'hardBounces' | 'softBounces' | 'delivered' | 'spam' | 'requests' | 'opened' | 'clicks' | 'invalid' | 'deferred' | 'blocked' | 'unsubscribed' | 'error', tags?: string, messageId?: string, templateId?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetEmailEventReport;  }> {
        const localVarPath = this.basePath + '/smtp/statistics/events';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "'bounces' | 'hardBounces' | 'softBounces' | 'delivered' | 'spam' | 'requests' | 'opened' | 'clicks' | 'invalid' | 'deferred' | 'blocked' | 'unsubscribed' | 'error'");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (messageId !== undefined) {
            localVarQueryParameters['messageId'] = ObjectSerializer.serialize(messageId, "string");
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetEmailEventReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetEmailEventReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your transactional email activity aggregated per day
     * @param limit Number of documents returned per page
     * @param offset Index of the first document on the page
     * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD)
     * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD)
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param tag Tag of the emails
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getSmtpReport (limit?: number, offset?: number, startDate?: string, endDate?: string, days?: number, tag?: string, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetReports;  }> {
        const localVarPath = this.basePath + '/smtp/statistics/reports';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetReports;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetReports");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns the template information
     * @param templateId id of the template
     * @param {*} [options] Override http request options.
     */
    public getSmtpTemplate (templateId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSmtpTemplateOverview;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling getSmtpTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSmtpTemplateOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmtpTemplateOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of email templates
     * @param templateStatus Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false
     * @param limit Number of documents returned per page
     * @param offset Index of the first document in the page
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getSmtpTemplates (templateStatus?: boolean, limit?: number, offset?: number, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSmtpTemplates;  }> {
        const localVarPath = this.basePath + '/smtp/templates';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (templateStatus !== undefined) {
            localVarQueryParameters['templateStatus'] = ObjectSerializer.serialize(templateStatus, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSmtpTemplates;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmtpTemplates");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of blocked or unsubscribed transactional contacts
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts
     * @param limit Number of documents returned per page
     * @param offset Index of the first document on the page
     * @param senders Comma separated list of emails of the senders from which contacts are blocked or unsubscribed
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getTransacBlockedContacts (startDate?: string, endDate?: string, limit?: number, offset?: number, senders?: Array<string>, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetTransacBlockedContacts;  }> {
        const localVarPath = this.basePath + '/smtp/blockedContacts';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (senders !== undefined) {
            localVarQueryParameters['senders'] = ObjectSerializer.serialize(senders, "Array<string>");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetTransacBlockedContacts;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacBlockedContacts");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the personalized content of a sent transactional email
     * @param uuid Unique id of the transactional email that has been sent to a particular contact
     * @param {*} [options] Override http request options.
     */
    public getTransacEmailContent (uuid: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetTransacEmailContent;  }> {
        const localVarPath = this.basePath + '/smtp/emails/{uuid}'
            .replace('{' + 'uuid' + '}', encodeURIComponent(String(uuid)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getTransacEmailContent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetTransacEmailContent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacEmailContent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
     * @summary Get the list of transactional emails on the basis of allowed filters
     * @param email Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent.
     * @param templateId Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email.
     * @param messageId Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent.
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month.
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getTransacEmailsList (email?: string, templateId?: number, messageId?: string, startDate?: string, endDate?: string, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetTransacEmailsList;  }> {
        const localVarPath = this.basePath + '/smtp/emails';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "number");
        }

        if (messageId !== undefined) {
            localVarQueryParameters['messageId'] = ObjectSerializer.serialize(messageId, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetTransacEmailsList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacEmailsList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint is deprecated. Prefer v3/smtp/email instead.
     * @summary Send a template
     * @param templateId Id of the template
     * @param sendEmail 
     * @param {*} [options] Override http request options.
     */
    public sendTemplate (templateId: number, sendEmail: SendEmail, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SendTemplateEmail;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}/send'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling sendTemplate.');
        }

        // verify required parameter 'sendEmail' is not null or undefined
        if (sendEmail === null || sendEmail === undefined) {
            throw new Error('Required parameter sendEmail was null or undefined when calling sendTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendEmail, "SendEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SendTemplateEmail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SendTemplateEmail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a template to your test list
     * @param templateId Id of the template
     * @param sendTestEmail 
     * @param {*} [options] Override http request options.
     */
    public sendTestTemplate (templateId: number, sendTestEmail: SendTestEmail, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}/sendTest'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling sendTestTemplate.');
        }

        // verify required parameter 'sendTestEmail' is not null or undefined
        if (sendTestEmail === null || sendTestEmail === undefined) {
            throw new Error('Required parameter sendTestEmail was null or undefined when calling sendTestTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendTestEmail, "SendTestEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send a transactional email
     * @param sendSmtpEmail Values to send a transactional email
     * @param {*} [options] Override http request options.
     */
    public sendTransacEmail (sendSmtpEmail: SendSmtpEmail, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateSmtpEmail;  }> {
        const localVarPath = this.basePath + '/smtp/email';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'sendSmtpEmail' is not null or undefined
        if (sendSmtpEmail === null || sendSmtpEmail === undefined) {
            throw new Error('Required parameter sendSmtpEmail was null or undefined when calling sendTransacEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendSmtpEmail, "SendSmtpEmail")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateSmtpEmail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSmtpEmail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unblock or resubscribe a transactional contact
     * @param email contact email (urlencoded) to unblock.
     * @param {*} [options] Override http request options.
     */
    public smtpBlockedContactsEmailDelete (email: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/blockedContacts/{email}'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling smtpBlockedContactsEmailDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an SMTP transactional log
     * @param messageId MessageId of the transactional log to delete
     * @param {*} [options] Override http request options.
     */
    public smtpLogMessageIdDelete (messageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/log/{messageId}'
            .replace('{' + 'messageId' + '}', encodeURIComponent(String(messageId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling smtpLogMessageIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an email template
     * @param templateId id of the template
     * @param smtpTemplate values to update in transactional email template
     * @param {*} [options] Override http request options.
     */
    public updateSmtpTemplate (templateId: number, smtpTemplate: UpdateSmtpTemplate, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/smtp/templates/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling updateSmtpTemplate.');
        }

        // verify required parameter 'smtpTemplate' is not null or undefined
        if (smtpTemplate === null || smtpTemplate === undefined) {
            throw new Error('Required parameter smtpTemplate was null or undefined when calling updateSmtpTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smtpTemplate, "UpdateSmtpTemplate")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionalSMSApiApiKeys {
    apiKey,
    partnerKey,
}

export class TransactionalSMSApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionalSMSApiApiKeys, value: string) {
        (this.authentications as any)[TransactionalSMSApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all your SMS activity (unaggregated events)
     * @param limit Number of documents per page
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
     * @param offset Index of the first document of the page
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param phoneNumber Filter the report for a specific phone number
     * @param event Filter the report for specific events
     * @param tags Filter the report for specific tags passed as a serialized urlencoded array
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getSmsEvents (limit?: number, startDate?: string, endDate?: string, offset?: number, days?: number, phoneNumber?: string, event?: 'bounces' | 'hardBounces' | 'softBounces' | 'delivered' | 'sent' | 'accepted' | 'unsubscription' | 'replies' | 'blocked', tags?: string, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetSmsEventReport;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/statistics/events';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "'bounces' | 'hardBounces' | 'softBounces' | 'delivered' | 'sent' | 'accepted' | 'unsubscription' | 'replies' | 'blocked'");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetSmsEventReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSmsEventReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your SMS activity aggregated over a period of time
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
     * @param days Number of days in the past including today (positive integer). Not compatible with startDate and endDate
     * @param tag Filter on a tag
     * @param {*} [options] Override http request options.
     */
    public getTransacAggregatedSmsReport (startDate?: string, endDate?: string, days?: number, tag?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetTransacAggregatedSmsReport;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/statistics/aggregatedReport';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetTransacAggregatedSmsReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacAggregatedSmsReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get your SMS activity aggregated per day
     * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
     * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
     * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
     * @param tag Filter on a tag
     * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
     * @param {*} [options] Override http request options.
     */
    public getTransacSmsReport (startDate?: string, endDate?: string, days?: number, tag?: string, sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetTransacSmsReport;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/statistics/reports';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetTransacSmsReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetTransacSmsReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send SMS message to a mobile number
     * @param sendTransacSms Values to send a transactional SMS
     * @param {*} [options] Override http request options.
     */
    public sendTransacSms (sendTransacSms: SendTransacSms, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SendSms;  }> {
        const localVarPath = this.basePath + '/transactionalSMS/sms';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'sendTransacSms' is not null or undefined
        if (sendTransacSms === null || sendTransacSms === undefined) {
            throw new Error('Required parameter sendTransacSms was null or undefined when calling sendTransacSms.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(sendTransacSms, "SendTransacSms")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SendSms;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SendSms");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhooksApiApiKeys {
    apiKey,
    partnerKey,
}

export class WebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring  = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'api-key'),
        'partnerKey': new ApiKeyAuth('header', 'partner-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhooksApiApiKeys, value: string) {
        (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a webhook
     * @param createWebhook Values to create a webhook
     * @param {*} [options] Override http request options.
     */
    public createWebhook (createWebhook: CreateWebhook, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateModel;  }> {
        const localVarPath = this.basePath + '/webhooks';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'createWebhook' is not null or undefined
        if (createWebhook === null || createWebhook === undefined) {
            throw new Error('Required parameter createWebhook was null or undefined when calling createWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createWebhook, "CreateWebhook")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a webhook
     * @param webhookId Id of the webhook
     * @param {*} [options] Override http request options.
     */
    public deleteWebhook (webhookId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling deleteWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a webhook details
     * @param webhookId Id of the webhook
     * @param {*} [options] Override http request options.
     */
    public getWebhook (webhookId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetWebhook;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling getWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetWebhook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetWebhook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all webhooks
     * @param type Filter on webhook type
     * @param sort Sort the results in the ascending/descending order of webhook creation
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (type?: 'marketing' | 'transactional', sort?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body: GetWebhooks;  }> {
        const localVarPath = this.basePath + '/webhooks';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'marketing' | 'transactional'");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'asc' | 'desc'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GetWebhooks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetWebhooks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook
     * @param webhookId Id of the webhook
     * @param updateWebhook Values to update a webhook
     * @param {*} [options] Override http request options.
     */
    public updateWebhook (webhookId: number, updateWebhook: UpdateWebhook, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling updateWebhook.');
        }

        // verify required parameter 'updateWebhook' is not null or undefined
        if (updateWebhook === null || updateWebhook === undefined) {
            throw new Error('Required parameter updateWebhook was null or undefined when calling updateWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateWebhook, "UpdateWebhook")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
